{"ast":null,"code":"\"use client\";\n\nimport { useFocusRing as Oe } from \"@react-aria/focus\";\nimport { useHover as Le } from \"@react-aria/interactions\";\nimport y, { createContext as te, createRef as ie, useContext as oe, useEffect as re, useMemo as I, useReducer as Ie, useRef as X, useState as ge } from \"react\";\nimport { useActivePress as De } from '../../hooks/use-active-press.js';\nimport { useElementSize as he } from '../../hooks/use-element-size.js';\nimport { useEvent as A } from '../../hooks/use-event.js';\nimport { useEventListener as ke } from '../../hooks/use-event-listener.js';\nimport { useId as ne } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as Ge } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as Se } from '../../hooks/use-latest-value.js';\nimport { useOnDisappear as He } from '../../hooks/use-on-disappear.js';\nimport { useOutsideClick as Ue } from '../../hooks/use-outside-click.js';\nimport { useOwnerDocument as de } from '../../hooks/use-owner.js';\nimport { useResolveButtonType as Ne } from '../../hooks/use-resolve-button-type.js';\nimport { MainTreeProvider as Ae, useMainTreeNode as we, useRootContainers as Ke } from '../../hooks/use-root-containers.js';\nimport { useScrollLock as We } from '../../hooks/use-scroll-lock.js';\nimport { optionalRef as je, useSyncRefs as q } from '../../hooks/use-sync-refs.js';\nimport { Direction as h, useTabDirection as Ce } from '../../hooks/use-tab-direction.js';\nimport { transitionDataAttributes as Be, useTransition as Re } from '../../hooks/use-transition.js';\nimport { CloseProvider as Ve } from '../../internal/close-provider.js';\nimport { FloatingProvider as $e, useFloatingPanel as Je, useFloatingPanelProps as Xe, useFloatingReference as qe, useResolvedAnchor as ze } from '../../internal/floating.js';\nimport { Hidden as Pe, HiddenFeatures as fe } from '../../internal/hidden.js';\nimport { OpenClosedProvider as Ye, ResetOpenClosedProvider as Qe, State as z, useOpenClosed as _e } from '../../internal/open-closed.js';\nimport { isDisabledReactIssue7711 as Fe } from '../../utils/bugs.js';\nimport { Focus as k, FocusResult as ce, FocusableMode as Ze, focusIn as w, getFocusableElements as ve, isFocusableElement as et } from '../../utils/focus-management.js';\nimport { match as K } from '../../utils/match.js';\nimport '../../utils/micro-task.js';\nimport { getOwnerDocument as tt } from '../../utils/owner.js';\nimport { RenderFeatures as le, forwardRefWithAs as Y, mergeProps as Te, render as ee, useMergeRefsFn as ot } from '../../utils/render.js';\nimport { Keys as W } from '../keyboard.js';\nimport { Portal as rt, useNestedPortals as nt } from '../portal/portal.js';\nvar lt = (P => (P[P.Open = 0] = \"Open\", P[P.Closed = 1] = \"Closed\", P))(lt || {}),\n  at = (s => (s[s.TogglePopover = 0] = \"TogglePopover\", s[s.ClosePopover = 1] = \"ClosePopover\", s[s.SetButton = 2] = \"SetButton\", s[s.SetButtonId = 3] = \"SetButtonId\", s[s.SetPanel = 4] = \"SetPanel\", s[s.SetPanelId = 5] = \"SetPanelId\", s))(at || {});\nlet pt = {\n    [0]: t => ({\n      ...t,\n      popoverState: K(t.popoverState, {\n        [0]: 1,\n        [1]: 0\n      }),\n      __demoMode: !1\n    }),\n    [1](t) {\n      return t.popoverState === 1 ? t : {\n        ...t,\n        popoverState: 1,\n        __demoMode: !1\n      };\n    },\n    [2](t, l) {\n      return t.button === l.button ? t : {\n        ...t,\n        button: l.button\n      };\n    },\n    [3](t, l) {\n      return t.buttonId === l.buttonId ? t : {\n        ...t,\n        buttonId: l.buttonId\n      };\n    },\n    [4](t, l) {\n      return t.panel === l.panel ? t : {\n        ...t,\n        panel: l.panel\n      };\n    },\n    [5](t, l) {\n      return t.panelId === l.panelId ? t : {\n        ...t,\n        panelId: l.panelId\n      };\n    }\n  },\n  me = te(null);\nme.displayName = \"PopoverContext\";\nfunction ae(t) {\n  let l = oe(me);\n  if (l === null) {\n    let P = new Error(`<${t} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(P, ae), P;\n  }\n  return l;\n}\nlet pe = te(null);\npe.displayName = \"PopoverAPIContext\";\nfunction ye(t) {\n  let l = oe(pe);\n  if (l === null) {\n    let P = new Error(`<${t} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(P, ye), P;\n  }\n  return l;\n}\nlet Ee = te(null);\nEe.displayName = \"PopoverGroupContext\";\nfunction xe() {\n  return oe(Ee);\n}\nlet se = te(null);\nse.displayName = \"PopoverPanelContext\";\nfunction st() {\n  return oe(se);\n}\nfunction ut(t, l) {\n  return K(l.type, pt, t, l);\n}\nlet it = \"div\";\nfunction dt(t, l) {\n  var f;\n  let {\n      __demoMode: P = !1,\n      ...R\n    } = t,\n    T = X(null),\n    C = q(l, je(o => {\n      T.current = o;\n    })),\n    s = X([]),\n    n = Ie(ut, {\n      __demoMode: P,\n      popoverState: P ? 0 : 1,\n      buttons: s,\n      button: null,\n      buttonId: null,\n      panel: null,\n      panelId: null,\n      beforePanelSentinel: ie(),\n      afterPanelSentinel: ie(),\n      afterButtonSentinel: ie()\n    }),\n    [{\n      popoverState: c,\n      button: i,\n      buttonId: r,\n      panel: d,\n      panelId: _,\n      beforePanelSentinel: m,\n      afterPanelSentinel: E,\n      afterButtonSentinel: u\n    }, a] = n,\n    v = de((f = T.current) != null ? f : i),\n    L = I(() => {\n      if (!i || !d) return !1;\n      for (let M of document.querySelectorAll(\"body > *\")) if (Number(M == null ? void 0 : M.contains(i)) ^ Number(M == null ? void 0 : M.contains(d))) return !0;\n      let o = ve(),\n        e = o.indexOf(i),\n        p = (e + o.length - 1) % o.length,\n        g = (e + 1) % o.length,\n        S = o[p],\n        B = o[g];\n      return !d.contains(S) && !d.contains(B);\n    }, [i, d]),\n    F = Se(r),\n    G = Se(_),\n    j = I(() => ({\n      buttonId: F,\n      panelId: G,\n      close: () => a({\n        type: 1\n      })\n    }), [F, G, a]),\n    b = xe(),\n    D = b == null ? void 0 : b.registerPopover,\n    H = A(() => {\n      var o;\n      return (o = b == null ? void 0 : b.isFocusWithinPopoverGroup()) != null ? o : (v == null ? void 0 : v.activeElement) && ((i == null ? void 0 : i.contains(v.activeElement)) || (d == null ? void 0 : d.contains(v.activeElement)));\n    });\n  re(() => D == null ? void 0 : D(j), [D, j]);\n  let [O, V] = nt(),\n    U = we(i),\n    N = Ke({\n      mainTreeNode: U,\n      portals: O,\n      defaultContainers: [i, d]\n    });\n  ke(v == null ? void 0 : v.defaultView, \"focus\", o => {\n    var e, p, g, S, B, M;\n    o.target !== window && o.target instanceof HTMLElement && c === 0 && (H() || i && d && (N.contains(o.target) || (p = (e = m.current) == null ? void 0 : e.contains) != null && p.call(e, o.target) || (S = (g = E.current) == null ? void 0 : g.contains) != null && S.call(g, o.target) || (M = (B = u.current) == null ? void 0 : B.contains) != null && M.call(B, o.target) || a({\n      type: 1\n    })));\n  }, !0), Ue(c === 0, N.resolveContainers, (o, e) => {\n    a({\n      type: 1\n    }), et(e, Ze.Loose) || (o.preventDefault(), i == null || i.focus());\n  });\n  let x = A(o => {\n      a({\n        type: 1\n      });\n      let e = (() => o ? o instanceof HTMLElement ? o : \"current\" in o && o.current instanceof HTMLElement ? o.current : i : i)();\n      e == null || e.focus();\n    }),\n    $ = I(() => ({\n      close: x,\n      isPortalled: L\n    }), [x, L]),\n    J = I(() => ({\n      open: c === 0,\n      close: x\n    }), [c, x]),\n    Z = {\n      ref: C\n    };\n  return y.createElement(Ae, {\n    node: U\n  }, y.createElement($e, null, y.createElement(se.Provider, {\n    value: null\n  }, y.createElement(me.Provider, {\n    value: n\n  }, y.createElement(pe.Provider, {\n    value: $\n  }, y.createElement(Ve, {\n    value: x\n  }, y.createElement(Ye, {\n    value: K(c, {\n      [0]: z.Open,\n      [1]: z.Closed\n    })\n  }, y.createElement(V, null, ee({\n    ourProps: Z,\n    theirProps: R,\n    slot: J,\n    defaultTag: it,\n    name: \"Popover\"\n  })))))))));\n}\nlet Pt = \"button\";\nfunction ft(t, l) {\n  let P = ne(),\n    {\n      id: R = `headlessui-popover-button-${P}`,\n      disabled: T = !1,\n      autoFocus: C = !1,\n      ...s\n    } = t,\n    [n, c] = ae(\"Popover.Button\"),\n    {\n      isPortalled: i\n    } = ye(\"Popover.Button\"),\n    r = X(null),\n    d = `headlessui-focus-sentinel-${ne()}`,\n    _ = xe(),\n    m = _ == null ? void 0 : _.closeOthers,\n    u = st() !== null;\n  re(() => {\n    if (!u) return c({\n      type: 3,\n      buttonId: R\n    }), () => {\n      c({\n        type: 3,\n        buttonId: null\n      });\n    };\n  }, [u, R, c]);\n  let [a] = ge(() => Symbol()),\n    v = q(r, l, qe(), u ? null : e => {\n      if (e) n.buttons.current.push(a);else {\n        let p = n.buttons.current.indexOf(a);\n        p !== -1 && n.buttons.current.splice(p, 1);\n      }\n      n.buttons.current.length > 1 && console.warn(\"You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported.\"), e && c({\n        type: 2,\n        button: e\n      });\n    }),\n    L = q(r, l),\n    F = de(r),\n    G = A(e => {\n      var p, g, S;\n      if (u) {\n        if (n.popoverState === 1) return;\n        switch (e.key) {\n          case W.Space:\n          case W.Enter:\n            e.preventDefault(), (g = (p = e.target).click) == null || g.call(p), c({\n              type: 1\n            }), (S = n.button) == null || S.focus();\n            break;\n        }\n      } else switch (e.key) {\n        case W.Space:\n        case W.Enter:\n          e.preventDefault(), e.stopPropagation(), n.popoverState === 1 && (m == null || m(n.buttonId)), c({\n            type: 0\n          });\n          break;\n        case W.Escape:\n          if (n.popoverState !== 0) return m == null ? void 0 : m(n.buttonId);\n          if (!r.current || F != null && F.activeElement && !r.current.contains(F.activeElement)) return;\n          e.preventDefault(), e.stopPropagation(), c({\n            type: 1\n          });\n          break;\n      }\n    }),\n    j = A(e => {\n      u || e.key === W.Space && e.preventDefault();\n    }),\n    b = A(e => {\n      var p, g;\n      Fe(e.currentTarget) || T || (u ? (c({\n        type: 1\n      }), (p = n.button) == null || p.focus()) : (e.preventDefault(), e.stopPropagation(), n.popoverState === 1 && (m == null || m(n.buttonId)), c({\n        type: 0\n      }), (g = n.button) == null || g.focus()));\n    }),\n    D = A(e => {\n      e.preventDefault(), e.stopPropagation();\n    }),\n    {\n      isFocusVisible: H,\n      focusProps: O\n    } = Oe({\n      autoFocus: C\n    }),\n    {\n      isHovered: V,\n      hoverProps: U\n    } = Le({\n      isDisabled: T\n    }),\n    {\n      pressed: N,\n      pressProps: Q\n    } = De({\n      disabled: T\n    }),\n    x = n.popoverState === 0,\n    $ = I(() => ({\n      open: x,\n      active: N || x,\n      disabled: T,\n      hover: V,\n      focus: H,\n      autofocus: C\n    }), [x, V, H, N, T, C]),\n    J = Ne(t, r),\n    Z = u ? Te({\n      ref: L,\n      type: J,\n      onKeyDown: G,\n      onClick: b,\n      disabled: T || void 0,\n      autoFocus: C\n    }, O, U, Q) : Te({\n      ref: v,\n      id: n.buttonId,\n      type: J,\n      \"aria-expanded\": n.popoverState === 0,\n      \"aria-controls\": n.panel ? n.panelId : void 0,\n      disabled: T || void 0,\n      autoFocus: C,\n      onKeyDown: G,\n      onKeyUp: j,\n      onClick: b,\n      onMouseDown: D\n    }, O, U, Q),\n    f = Ce(),\n    o = A(() => {\n      let e = n.panel;\n      if (!e) return;\n      function p() {\n        K(f.current, {\n          [h.Forwards]: () => w(e, k.First),\n          [h.Backwards]: () => w(e, k.Last)\n        }) === ce.Error && w(ve().filter(S => S.dataset.headlessuiFocusGuard !== \"true\"), K(f.current, {\n          [h.Forwards]: k.Next,\n          [h.Backwards]: k.Previous\n        }), {\n          relativeTo: n.button\n        });\n      }\n      p();\n    });\n  return y.createElement(y.Fragment, null, ee({\n    ourProps: Z,\n    theirProps: s,\n    slot: $,\n    defaultTag: Pt,\n    name: \"Popover.Button\"\n  }), x && !u && i && y.createElement(Pe, {\n    id: d,\n    ref: n.afterButtonSentinel,\n    features: fe.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: o\n  }));\n}\nlet ct = \"div\",\n  vt = le.RenderStrategy | le.Static;\nfunction Me(t, l) {\n  let P = ne(),\n    {\n      id: R = `headlessui-popover-backdrop-${P}`,\n      transition: T = !1,\n      ...C\n    } = t,\n    [{\n      popoverState: s\n    }, n] = ae(\"Popover.Backdrop\"),\n    c = X(null),\n    i = q(l, c),\n    r = _e(),\n    [d, _] = Re(T, c, r !== null ? (r & z.Open) === z.Open : s === 0),\n    m = A(a => {\n      if (Fe(a.currentTarget)) return a.preventDefault();\n      n({\n        type: 1\n      });\n    }),\n    E = I(() => ({\n      open: s === 0\n    }), [s]),\n    u = {\n      ref: i,\n      id: R,\n      \"aria-hidden\": !0,\n      onClick: m,\n      ...Be(_)\n    };\n  return ee({\n    ourProps: u,\n    theirProps: C,\n    slot: E,\n    defaultTag: ct,\n    features: vt,\n    visible: d,\n    name: \"Popover.Backdrop\"\n  });\n}\nlet Tt = \"div\",\n  mt = le.RenderStrategy | le.Static;\nfunction yt(t, l) {\n  let P = ne(),\n    {\n      id: R = `headlessui-popover-panel-${P}`,\n      focus: T = !1,\n      anchor: C,\n      portal: s = !1,\n      modal: n = !1,\n      transition: c = !1,\n      ...i\n    } = t,\n    [r, d] = ae(\"Popover.Panel\"),\n    {\n      close: _,\n      isPortalled: m\n    } = ye(\"Popover.Panel\"),\n    E = `headlessui-focus-sentinel-before-${P}`,\n    u = `headlessui-focus-sentinel-after-${P}`,\n    a = X(null),\n    v = ze(C),\n    [L, F] = Je(v),\n    G = Xe();\n  v && (s = !0);\n  let j = q(a, l, v ? L : null, f => {\n      d({\n        type: 4,\n        panel: f\n      });\n    }),\n    b = de(a),\n    D = ot();\n  Ge(() => (d({\n    type: 5,\n    panelId: R\n  }), () => {\n    d({\n      type: 5,\n      panelId: null\n    });\n  }), [R, d]);\n  let H = _e(),\n    [O, V] = Re(c, a, H !== null ? (H & z.Open) === z.Open : r.popoverState === 0);\n  He(O, r.button, () => {\n    d({\n      type: 1\n    });\n  });\n  let U = r.__demoMode ? !1 : n && O;\n  We(U, b);\n  let N = A(f => {\n    var o;\n    switch (f.key) {\n      case W.Escape:\n        if (r.popoverState !== 0 || !a.current || b != null && b.activeElement && !a.current.contains(b.activeElement)) return;\n        f.preventDefault(), f.stopPropagation(), d({\n          type: 1\n        }), (o = r.button) == null || o.focus();\n        break;\n    }\n  });\n  re(() => {\n    var f;\n    t.static || r.popoverState === 1 && ((f = t.unmount) == null || f) && d({\n      type: 4,\n      panel: null\n    });\n  }, [r.popoverState, t.unmount, t.static, d]), re(() => {\n    if (r.__demoMode || !T || r.popoverState !== 0 || !a.current) return;\n    let f = b == null ? void 0 : b.activeElement;\n    a.current.contains(f) || w(a.current, k.First);\n  }, [r.__demoMode, T, a.current, r.popoverState]);\n  let Q = I(() => ({\n      open: r.popoverState === 0,\n      close: _\n    }), [r.popoverState, _]),\n    x = Te(v ? G() : {}, {\n      ref: j,\n      id: R,\n      onKeyDown: N,\n      onBlur: T && r.popoverState === 0 ? f => {\n        var e, p, g, S, B;\n        let o = f.relatedTarget;\n        o && a.current && ((e = a.current) != null && e.contains(o) || (d({\n          type: 1\n        }), ((g = (p = r.beforePanelSentinel.current) == null ? void 0 : p.contains) != null && g.call(p, o) || (B = (S = r.afterPanelSentinel.current) == null ? void 0 : S.contains) != null && B.call(S, o)) && o.focus({\n          preventScroll: !0\n        })));\n      } : void 0,\n      tabIndex: -1,\n      style: {\n        ...i.style,\n        ...F,\n        \"--button-width\": he(r.button, !0).width\n      },\n      ...Be(V)\n    }),\n    $ = Ce(),\n    J = A(() => {\n      let f = a.current;\n      if (!f) return;\n      function o() {\n        K($.current, {\n          [h.Forwards]: () => {\n            var p;\n            w(f, k.First) === ce.Error && ((p = r.afterPanelSentinel.current) == null || p.focus());\n          },\n          [h.Backwards]: () => {\n            var e;\n            (e = r.button) == null || e.focus({\n              preventScroll: !0\n            });\n          }\n        });\n      }\n      o();\n    }),\n    Z = A(() => {\n      let f = a.current;\n      if (!f) return;\n      function o() {\n        K($.current, {\n          [h.Forwards]: () => {\n            var M;\n            if (!r.button) return;\n            let e = ve(),\n              p = e.indexOf(r.button),\n              g = e.slice(0, p + 1),\n              B = [...e.slice(p + 1), ...g];\n            for (let ue of B.slice()) if (ue.dataset.headlessuiFocusGuard === \"true\" || (M = r.panel) != null && M.contains(ue)) {\n              let be = B.indexOf(ue);\n              be !== -1 && B.splice(be, 1);\n            }\n            w(B, k.First, {\n              sorted: !1\n            });\n          },\n          [h.Backwards]: () => {\n            var p;\n            w(f, k.Previous) === ce.Error && ((p = r.button) == null || p.focus());\n          }\n        });\n      }\n      o();\n    });\n  return y.createElement(Qe, null, y.createElement(se.Provider, {\n    value: R\n  }, y.createElement(pe.Provider, {\n    value: {\n      close: _,\n      isPortalled: m\n    }\n  }, y.createElement(rt, {\n    enabled: s ? t.static || O : !1\n  }, O && m && y.createElement(Pe, {\n    id: E,\n    ref: r.beforePanelSentinel,\n    features: fe.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: J\n  }), ee({\n    mergeRefs: D,\n    ourProps: x,\n    theirProps: i,\n    slot: Q,\n    defaultTag: Tt,\n    features: mt,\n    visible: O,\n    name: \"Popover.Panel\"\n  }), O && m && y.createElement(Pe, {\n    id: u,\n    ref: r.afterPanelSentinel,\n    features: fe.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: Z\n  })))));\n}\nlet Et = \"div\";\nfunction bt(t, l) {\n  let P = X(null),\n    R = q(P, l),\n    [T, C] = ge([]),\n    s = A(E => {\n      C(u => {\n        let a = u.indexOf(E);\n        if (a !== -1) {\n          let v = u.slice();\n          return v.splice(a, 1), v;\n        }\n        return u;\n      });\n    }),\n    n = A(E => (C(u => [...u, E]), () => s(E))),\n    c = A(() => {\n      var a;\n      let E = tt(P);\n      if (!E) return !1;\n      let u = E.activeElement;\n      return (a = P.current) != null && a.contains(u) ? !0 : T.some(v => {\n        var L, F;\n        return ((L = E.getElementById(v.buttonId.current)) == null ? void 0 : L.contains(u)) || ((F = E.getElementById(v.panelId.current)) == null ? void 0 : F.contains(u));\n      });\n    }),\n    i = A(E => {\n      for (let u of T) u.buttonId.current !== E && u.close();\n    }),\n    r = I(() => ({\n      registerPopover: n,\n      unregisterPopover: s,\n      isFocusWithinPopoverGroup: c,\n      closeOthers: i\n    }), [n, s, c, i]),\n    d = I(() => ({}), []),\n    _ = t,\n    m = {\n      ref: R\n    };\n  return y.createElement(Ae, null, y.createElement(Ee.Provider, {\n    value: r\n  }, ee({\n    ourProps: m,\n    theirProps: _,\n    slot: d,\n    defaultTag: Et,\n    name: \"Popover.Group\"\n  })));\n}\nlet gt = Y(dt),\n  St = Y(ft),\n  At = Y(Me),\n  Ct = Y(Me),\n  Bt = Y(yt),\n  Rt = Y(bt),\n  lo = Object.assign(gt, {\n    Button: St,\n    Backdrop: Ct,\n    Overlay: At,\n    Panel: Bt,\n    Group: Rt\n  });\nexport { lo as Popover, Ct as PopoverBackdrop, St as PopoverButton, Rt as PopoverGroup, At as PopoverOverlay, Bt as PopoverPanel };","map":null,"metadata":{},"sourceType":"module"}