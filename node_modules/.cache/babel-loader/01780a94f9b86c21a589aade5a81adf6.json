{"ast":null,"code":"\"use client\";\n\nimport { useFocusRing as Q } from \"@react-aria/focus\";\nimport { useHover as Y } from \"@react-aria/interactions\";\nimport G, { createContext as Z, useCallback as ye, useContext as ee, useMemo as x, useReducer as Re, useRef as W } from \"react\";\nimport { useByComparator as be } from '../../hooks/use-by-comparator.js';\nimport { useControllable as ge } from '../../hooks/use-controllable.js';\nimport { useDefaultValue as Oe } from '../../hooks/use-default-value.js';\nimport { useEvent as S } from '../../hooks/use-event.js';\nimport { useId as B } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as te } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as oe } from '../../hooks/use-latest-value.js';\nimport { useSyncRefs as V } from '../../hooks/use-sync-refs.js';\nimport { useDisabled as re } from '../../internal/disabled.js';\nimport { FormFields as Pe } from '../../internal/form-fields.js';\nimport { useProvidedId as ve } from '../../internal/id.js';\nimport { isDisabledReactIssue7711 as ie } from '../../utils/bugs.js';\nimport { Focus as w, FocusResult as ne, focusIn as ae, sortByDomNode as De } from '../../utils/focus-management.js';\nimport { attemptSubmit as Ae } from '../../utils/form.js';\nimport { match as _e } from '../../utils/match.js';\nimport { getOwnerDocument as Ee } from '../../utils/owner.js';\nimport { forwardRefWithAs as K, mergeProps as pe, render as $ } from '../../utils/render.js';\nimport { Description as Ge, useDescribedBy as xe, useDescriptions as le } from '../description/description.js';\nimport { Keys as F } from '../keyboard.js';\nimport { Label as Ce, useLabelledBy as he, useLabels as se } from '../label/label.js';\nvar Le = (e => (e[e.RegisterOption = 0] = \"RegisterOption\", e[e.UnregisterOption = 1] = \"UnregisterOption\", e))(Le || {});\nlet ke = {\n    [0](o, t) {\n      let e = [...o.options, {\n        id: t.id,\n        element: t.element,\n        propsRef: t.propsRef\n      }];\n      return {\n        ...o,\n        options: De(e, a => a.element.current)\n      };\n    },\n    [1](o, t) {\n      let e = o.options.slice(),\n        a = o.options.findIndex(O => O.id === t.id);\n      return a === -1 ? o : (e.splice(a, 1), {\n        ...o,\n        options: e\n      });\n    }\n  },\n  j = Z(null);\nj.displayName = \"RadioGroupDataContext\";\nfunction J(o) {\n  let t = ee(j);\n  if (t === null) {\n    let e = new Error(`<${o} /> is missing a parent <RadioGroup /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(e, J), e;\n  }\n  return t;\n}\nlet X = Z(null);\nX.displayName = \"RadioGroupActionsContext\";\nfunction z(o) {\n  let t = ee(X);\n  if (t === null) {\n    let e = new Error(`<${o} /> is missing a parent <RadioGroup /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(e, z), e;\n  }\n  return t;\n}\nfunction Fe(o, t) {\n  return _e(t.type, ke, o, t);\n}\nlet Ie = \"div\";\nfunction Ue(o, t) {\n  let e = B(),\n    a = re(),\n    {\n      id: O = `headlessui-radiogroup-${e}`,\n      value: m,\n      form: P,\n      name: i,\n      onChange: f,\n      by: c,\n      disabled: p = a || !1,\n      defaultValue: I,\n      ...y\n    } = o,\n    T = be(c),\n    [v, C] = Re(Fe, {\n      options: []\n    }),\n    n = v.options,\n    [U, h] = se(),\n    [D, L] = le(),\n    A = W(null),\n    M = V(A, t),\n    l = Oe(I),\n    [s, _] = ge(m, f, l),\n    R = x(() => n.find(r => !r.propsRef.current.disabled), [n]),\n    b = x(() => n.some(r => T(r.propsRef.current.value, s)), [n, s]),\n    d = S(r => {\n      var u;\n      if (p || T(r, s)) return !1;\n      let k = (u = n.find(H => T(H.propsRef.current.value, r))) == null ? void 0 : u.propsRef.current;\n      return k != null && k.disabled ? !1 : (_ == null || _(r), !0);\n    }),\n    de = S(r => {\n      let k = A.current;\n      if (!k) return;\n      let u = Ee(k),\n        H = n.filter(g => g.propsRef.current.disabled === !1).map(g => g.element.current);\n      switch (r.key) {\n        case F.Enter:\n          Ae(r.currentTarget);\n          break;\n        case F.ArrowLeft:\n        case F.ArrowUp:\n          if (r.preventDefault(), r.stopPropagation(), ae(H, w.Previous | w.WrapAround) === ne.Success) {\n            let E = n.find(N => N.element.current === (u == null ? void 0 : u.activeElement));\n            E && d(E.propsRef.current.value);\n          }\n          break;\n        case F.ArrowRight:\n        case F.ArrowDown:\n          if (r.preventDefault(), r.stopPropagation(), ae(H, w.Next | w.WrapAround) === ne.Success) {\n            let E = n.find(N => N.element.current === (u == null ? void 0 : u.activeElement));\n            E && d(E.propsRef.current.value);\n          }\n          break;\n        case F.Space:\n          {\n            r.preventDefault(), r.stopPropagation();\n            let g = n.find(E => E.element.current === (u == null ? void 0 : u.activeElement));\n            g && d(g.propsRef.current.value);\n          }\n          break;\n      }\n    }),\n    q = S(r => (C({\n      type: 0,\n      ...r\n    }), () => C({\n      type: 1,\n      id: r.id\n    }))),\n    ue = x(() => ({\n      value: s,\n      firstOption: R,\n      containsCheckedOption: b,\n      disabled: p,\n      compare: T,\n      ...v\n    }), [s, R, b, p, T, v]),\n    ce = x(() => ({\n      registerOption: q,\n      change: d\n    }), [q, d]),\n    fe = {\n      ref: M,\n      id: O,\n      role: \"radiogroup\",\n      \"aria-labelledby\": U,\n      \"aria-describedby\": D,\n      onKeyDown: de\n    },\n    Te = x(() => ({\n      value: s\n    }), [s]),\n    me = ye(() => {\n      if (l !== void 0) return d(l);\n    }, [d, l]);\n  return G.createElement(L, {\n    name: \"RadioGroup.Description\"\n  }, G.createElement(h, {\n    name: \"RadioGroup.Label\"\n  }, G.createElement(X.Provider, {\n    value: ce\n  }, G.createElement(j.Provider, {\n    value: ue\n  }, i != null && G.createElement(Pe, {\n    disabled: p,\n    data: {\n      [i]: s || \"on\"\n    },\n    overrides: {\n      type: \"radio\",\n      checked: s != null\n    },\n    form: P,\n    onReset: me\n  }), $({\n    ourProps: fe,\n    theirProps: y,\n    slot: Te,\n    defaultTag: Ie,\n    name: \"RadioGroup\"\n  })))));\n}\nlet Me = \"div\";\nfunction Se(o, t) {\n  var R;\n  let e = J(\"RadioGroup.Option\"),\n    a = z(\"RadioGroup.Option\"),\n    O = B(),\n    {\n      id: m = `headlessui-radiogroup-option-${O}`,\n      value: P,\n      disabled: i = e.disabled || !1,\n      autoFocus: f = !1,\n      ...c\n    } = o,\n    p = W(null),\n    I = V(p, t),\n    [y, T] = se(),\n    [v, C] = le(),\n    n = oe({\n      value: P,\n      disabled: i\n    });\n  te(() => a.registerOption({\n    id: m,\n    element: p,\n    propsRef: n\n  }), [m, a, p, n]);\n  let U = S(b => {\n      var d;\n      if (ie(b.currentTarget)) return b.preventDefault();\n      a.change(P) && ((d = p.current) == null || d.focus());\n    }),\n    h = ((R = e.firstOption) == null ? void 0 : R.id) === m,\n    {\n      isFocusVisible: D,\n      focusProps: L\n    } = Q({\n      autoFocus: f\n    }),\n    {\n      isHovered: A,\n      hoverProps: M\n    } = Y({\n      isDisabled: i\n    }),\n    l = e.compare(e.value, P),\n    s = pe({\n      ref: I,\n      id: m,\n      role: \"radio\",\n      \"aria-checked\": l ? \"true\" : \"false\",\n      \"aria-labelledby\": y,\n      \"aria-describedby\": v,\n      \"aria-disabled\": i ? !0 : void 0,\n      tabIndex: (() => i ? -1 : l || !e.containsCheckedOption && h ? 0 : -1)(),\n      onClick: i ? void 0 : U,\n      autoFocus: f\n    }, L, M),\n    _ = x(() => ({\n      checked: l,\n      disabled: i,\n      active: D,\n      hover: A,\n      focus: D,\n      autofocus: f\n    }), [l, i, A, D, f]);\n  return G.createElement(C, {\n    name: \"RadioGroup.Description\"\n  }, G.createElement(T, {\n    name: \"RadioGroup.Label\"\n  }, $({\n    ourProps: s,\n    theirProps: c,\n    slot: _,\n    defaultTag: Me,\n    name: \"RadioGroup.Option\"\n  })));\n}\nlet He = \"span\";\nfunction we(o, t) {\n  var R;\n  let e = J(\"Radio\"),\n    a = z(\"Radio\"),\n    O = B(),\n    m = ve(),\n    P = re(),\n    {\n      id: i = m || `headlessui-radio-${O}`,\n      value: f,\n      disabled: c = e.disabled || P || !1,\n      autoFocus: p = !1,\n      ...I\n    } = o,\n    y = W(null),\n    T = V(y, t),\n    v = he(),\n    C = xe(),\n    n = oe({\n      value: f,\n      disabled: c\n    });\n  te(() => a.registerOption({\n    id: i,\n    element: y,\n    propsRef: n\n  }), [i, a, y, n]);\n  let U = S(b => {\n      var d;\n      if (ie(b.currentTarget)) return b.preventDefault();\n      a.change(f) && ((d = y.current) == null || d.focus());\n    }),\n    {\n      isFocusVisible: h,\n      focusProps: D\n    } = Q({\n      autoFocus: p\n    }),\n    {\n      isHovered: L,\n      hoverProps: A\n    } = Y({\n      isDisabled: c\n    }),\n    M = ((R = e.firstOption) == null ? void 0 : R.id) === i,\n    l = e.compare(e.value, f),\n    s = pe({\n      ref: T,\n      id: i,\n      role: \"radio\",\n      \"aria-checked\": l ? \"true\" : \"false\",\n      \"aria-labelledby\": v,\n      \"aria-describedby\": C,\n      \"aria-disabled\": c ? !0 : void 0,\n      tabIndex: (() => c ? -1 : l || !e.containsCheckedOption && M ? 0 : -1)(),\n      autoFocus: p,\n      onClick: c ? void 0 : U\n    }, D, A),\n    _ = x(() => ({\n      checked: l,\n      disabled: c,\n      hover: L,\n      focus: h,\n      autofocus: p\n    }), [l, c, L, h, p]);\n  return $({\n    ourProps: s,\n    theirProps: I,\n    slot: _,\n    defaultTag: He,\n    name: \"Radio\"\n  });\n}\nlet Ne = K(Ue),\n  We = K(Se),\n  Be = K(we),\n  Ve = Ce,\n  Ke = Ge,\n  Tt = Object.assign(Ne, {\n    Option: We,\n    Radio: Be,\n    Label: Ve,\n    Description: Ke\n  });\nexport { Be as Radio, Tt as RadioGroup, Ke as RadioGroupDescription, Ve as RadioGroupLabel, We as RadioGroupOption };","map":null,"metadata":{},"sourceType":"module"}