{"ast":null,"code":"\"use client\";\n\nimport { useFocusRing as ye } from \"@react-aria/focus\";\nimport { useHover as Ce } from \"@react-aria/interactions\";\nimport { useVirtualizer as ke } from \"@tanstack/react-virtual\";\nimport D, { Fragment as Re, createContext as be, createRef as Ne, useCallback as Se, useContext as fe, useMemo as z, useReducer as Ue, useRef as $, useState as He } from \"react\";\nimport { flushSync as Z } from \"react-dom\";\nimport { useActivePress as Ge } from '../../hooks/use-active-press.js';\nimport { useByComparator as je } from '../../hooks/use-by-comparator.js';\nimport { useControllable as ze } from '../../hooks/use-controllable.js';\nimport { useDefaultValue as Ke } from '../../hooks/use-default-value.js';\nimport { useDisposables as We } from '../../hooks/use-disposables.js';\nimport { useElementSize as Pe } from '../../hooks/use-element-size.js';\nimport { useEvent as m } from '../../hooks/use-event.js';\nimport { useId as pe } from '../../hooks/use-id.js';\nimport { useInertOthers as $e } from '../../hooks/use-inert-others.js';\nimport { useIsoMorphicEffect as X } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as Xe } from '../../hooks/use-latest-value.js';\nimport { useOnDisappear as Je } from '../../hooks/use-on-disappear.js';\nimport { useOutsideClick as qe } from '../../hooks/use-outside-click.js';\nimport { useOwnerDocument as Ae } from '../../hooks/use-owner.js';\nimport { useRefocusableInput as Ie } from '../../hooks/use-refocusable-input.js';\nimport { useResolveButtonType as Ye } from '../../hooks/use-resolve-button-type.js';\nimport { useScrollLock as Qe } from '../../hooks/use-scroll-lock.js';\nimport { useSyncRefs as se } from '../../hooks/use-sync-refs.js';\nimport { useTrackedPointer as Ze } from '../../hooks/use-tracked-pointer.js';\nimport { transitionDataAttributes as eo, useTransition as oo } from '../../hooks/use-transition.js';\nimport { useTreeWalker as to } from '../../hooks/use-tree-walker.js';\nimport { useWatch as Ee } from '../../hooks/use-watch.js';\nimport { useDisabled as no } from '../../internal/disabled.js';\nimport { FloatingProvider as ro, useFloatingPanel as io, useFloatingPanelProps as ao, useFloatingReference as lo, useResolvedAnchor as uo } from '../../internal/floating.js';\nimport { FormFields as po } from '../../internal/form-fields.js';\nimport { Frozen as so, useFrozenData as _e } from '../../internal/frozen.js';\nimport { useProvidedId as bo } from '../../internal/id.js';\nimport { OpenClosedProvider as fo, State as de, useOpenClosed as co } from '../../internal/open-closed.js';\nimport { history as he } from '../../utils/active-element-history.js';\nimport { isDisabledReactIssue7711 as mo } from '../../utils/bugs.js';\nimport { Focus as P, calculateActiveIndex as De } from '../../utils/calculate-active-index.js';\nimport { disposables as Me } from '../../utils/disposables.js';\nimport { sortByDomNode as To } from '../../utils/focus-management.js';\nimport { match as ee } from '../../utils/match.js';\nimport { isMobile as xo } from '../../utils/platform.js';\nimport { RenderFeatures as Fe, forwardRefWithAs as te, mergeProps as ce, render as ne } from '../../utils/render.js';\nimport { useDescribedBy as go } from '../description/description.js';\nimport { Keys as V } from '../keyboard.js';\nimport { Label as vo, useLabelledBy as me, useLabels as Oo } from '../label/label.js';\nimport { MouseButton as Ve } from '../mouse.js';\nimport { Portal as yo } from '../portal/portal.js';\nvar Co = (e => (e[e.Open = 0] = \"Open\", e[e.Closed = 1] = \"Closed\", e))(Co || {}),\n  Ro = (e => (e[e.Single = 0] = \"Single\", e[e.Multi = 1] = \"Multi\", e))(Ro || {}),\n  So = (t => (t[t.Pointer = 0] = \"Pointer\", t[t.Focus = 1] = \"Focus\", t[t.Other = 2] = \"Other\", t))(So || {}),\n  Po = (u => (u[u.OpenCombobox = 0] = \"OpenCombobox\", u[u.CloseCombobox = 1] = \"CloseCombobox\", u[u.GoToOption = 2] = \"GoToOption\", u[u.SetTyping = 3] = \"SetTyping\", u[u.RegisterOption = 4] = \"RegisterOption\", u[u.UnregisterOption = 5] = \"UnregisterOption\", u[u.SetActivationTrigger = 6] = \"SetActivationTrigger\", u[u.UpdateVirtualConfiguration = 7] = \"UpdateVirtualConfiguration\", u))(Po || {});\nfunction Te(o, r = e => e) {\n  let e = o.activeOptionIndex !== null ? o.options[o.activeOptionIndex] : null,\n    t = r(o.options.slice()),\n    c = t.length > 0 && t[0].dataRef.current.order !== null ? t.sort((f, s) => f.dataRef.current.order - s.dataRef.current.order) : To(t, f => f.dataRef.current.domRef.current),\n    d = e ? c.indexOf(e) : null;\n  return d === -1 && (d = null), {\n    options: c,\n    activeOptionIndex: d\n  };\n}\nlet Ao = {\n    [1](o) {\n      var r;\n      return (r = o.dataRef.current) != null && r.disabled || o.comboboxState === 1 ? o : {\n        ...o,\n        activeOptionIndex: null,\n        comboboxState: 1,\n        isTyping: !1,\n        activationTrigger: 2,\n        __demoMode: !1\n      };\n    },\n    [0](o) {\n      var r, e;\n      if ((r = o.dataRef.current) != null && r.disabled || o.comboboxState === 0) return o;\n      if ((e = o.dataRef.current) != null && e.value) {\n        let t = o.dataRef.current.calculateIndex(o.dataRef.current.value);\n        if (t !== -1) return {\n          ...o,\n          activeOptionIndex: t,\n          comboboxState: 0,\n          __demoMode: !1\n        };\n      }\n      return {\n        ...o,\n        comboboxState: 0,\n        __demoMode: !1\n      };\n    },\n    [3](o, r) {\n      return o.isTyping === r.isTyping ? o : {\n        ...o,\n        isTyping: r.isTyping\n      };\n    },\n    [2](o, r) {\n      var d, f, s, u, a;\n      if ((d = o.dataRef.current) != null && d.disabled || (f = o.dataRef.current) != null && f.optionsRef.current && !((s = o.dataRef.current) != null && s.optionsPropsRef.current.static) && o.comboboxState === 1) return o;\n      if (o.virtual) {\n        let {\n            options: n,\n            disabled: T\n          } = o.virtual,\n          C = r.focus === P.Specific ? r.idx : De(r, {\n            resolveItems: () => n,\n            resolveActiveIndex: () => {\n              var p, L;\n              return (L = (p = o.activeOptionIndex) != null ? p : n.findIndex(M => !T(M))) != null ? L : null;\n            },\n            resolveDisabled: T,\n            resolveId() {\n              throw new Error(\"Function not implemented.\");\n            }\n          }),\n          _ = (u = r.trigger) != null ? u : 2;\n        return o.activeOptionIndex === C && o.activationTrigger === _ ? o : {\n          ...o,\n          activeOptionIndex: C,\n          activationTrigger: _,\n          isTyping: !1,\n          __demoMode: !1\n        };\n      }\n      let e = Te(o);\n      if (e.activeOptionIndex === null) {\n        let n = e.options.findIndex(T => !T.dataRef.current.disabled);\n        n !== -1 && (e.activeOptionIndex = n);\n      }\n      let t = r.focus === P.Specific ? r.idx : De(r, {\n          resolveItems: () => e.options,\n          resolveActiveIndex: () => e.activeOptionIndex,\n          resolveId: n => n.id,\n          resolveDisabled: n => n.dataRef.current.disabled\n        }),\n        c = (a = r.trigger) != null ? a : 2;\n      return o.activeOptionIndex === t && o.activationTrigger === c ? o : {\n        ...o,\n        ...e,\n        isTyping: !1,\n        activeOptionIndex: t,\n        activationTrigger: c,\n        __demoMode: !1\n      };\n    },\n    [4]: (o, r) => {\n      var d, f, s;\n      if ((d = o.dataRef.current) != null && d.virtual) return {\n        ...o,\n        options: [...o.options, r.payload]\n      };\n      let e = r.payload,\n        t = Te(o, u => (u.push(e), u));\n      o.activeOptionIndex === null && (f = o.dataRef.current) != null && f.isSelected(r.payload.dataRef.current.value) && (t.activeOptionIndex = t.options.indexOf(e));\n      let c = {\n        ...o,\n        ...t,\n        activationTrigger: 2\n      };\n      return (s = o.dataRef.current) != null && s.__demoMode && o.dataRef.current.value === void 0 && (c.activeOptionIndex = 0), c;\n    },\n    [5]: (o, r) => {\n      var t;\n      if ((t = o.dataRef.current) != null && t.virtual) return {\n        ...o,\n        options: o.options.filter(c => c.id !== r.id)\n      };\n      let e = Te(o, c => {\n        let d = c.findIndex(f => f.id === r.id);\n        return d !== -1 && c.splice(d, 1), c;\n      });\n      return {\n        ...o,\n        ...e,\n        activationTrigger: 2\n      };\n    },\n    [6]: (o, r) => o.activationTrigger === r.trigger ? o : {\n      ...o,\n      activationTrigger: r.trigger\n    },\n    [7]: (o, r) => {\n      var t, c;\n      if (o.virtual === null) return {\n        ...o,\n        virtual: {\n          options: r.options,\n          disabled: (t = r.disabled) != null ? t : () => !1\n        }\n      };\n      if (o.virtual.options === r.options && o.virtual.disabled === r.disabled) return o;\n      let e = o.activeOptionIndex;\n      if (o.activeOptionIndex !== null) {\n        let d = r.options.indexOf(o.virtual.options[o.activeOptionIndex]);\n        d !== -1 ? e = d : e = null;\n      }\n      return {\n        ...o,\n        activeOptionIndex: e,\n        virtual: {\n          options: r.options,\n          disabled: (c = r.disabled) != null ? c : () => !1\n        }\n      };\n    }\n  },\n  xe = be(null);\nxe.displayName = \"ComboboxActionsContext\";\nfunction re(o) {\n  let r = fe(xe);\n  if (r === null) {\n    let e = new Error(`<${o} /> is missing a parent <Combobox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(e, re), e;\n  }\n  return r;\n}\nlet Le = be(null);\nfunction Io(o) {\n  let r = oe(\"VirtualProvider\"),\n    {\n      options: e\n    } = r.virtual,\n    [t, c] = z(() => {\n      let a = r.optionsRef.current;\n      if (!a) return [0, 0];\n      let n = window.getComputedStyle(a);\n      return [parseFloat(n.paddingBlockStart || n.paddingTop), parseFloat(n.paddingBlockEnd || n.paddingBottom)];\n    }, [r.optionsRef.current]),\n    d = ke({\n      enabled: e.length !== 0,\n      scrollPaddingStart: t,\n      scrollPaddingEnd: c,\n      count: e.length,\n      estimateSize() {\n        return 40;\n      },\n      getScrollElement() {\n        var a;\n        return (a = r.optionsRef.current) != null ? a : null;\n      },\n      overscan: 12\n    }),\n    [f, s] = He(0);\n  X(() => {\n    s(a => a + 1);\n  }, [e]);\n  let u = d.getVirtualItems();\n  return u.length === 0 ? null : D.createElement(Le.Provider, {\n    value: d\n  }, D.createElement(\"div\", {\n    style: {\n      position: \"relative\",\n      width: \"100%\",\n      height: `${d.getTotalSize()}px`\n    },\n    ref: a => {\n      if (a) {\n        if (typeof process != \"undefined\" && process.env.JEST_WORKER_ID !== void 0 || r.activationTrigger === 0) return;\n        r.activeOptionIndex !== null && e.length > r.activeOptionIndex && d.scrollToIndex(r.activeOptionIndex);\n      }\n    }\n  }, u.map(a => {\n    var n;\n    return D.createElement(Re, {\n      key: a.key\n    }, D.cloneElement((n = o.children) == null ? void 0 : n.call(o, {\n      ...o.slot,\n      option: e[a.index]\n    }), {\n      key: `${f}-${a.key}`,\n      \"data-index\": a.index,\n      \"aria-setsize\": e.length,\n      \"aria-posinset\": a.index + 1,\n      style: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        transform: `translateY(${a.start}px)`,\n        overflowAnchor: \"none\"\n      }\n    }));\n  })));\n}\nlet ie = be(null);\nie.displayName = \"ComboboxDataContext\";\nfunction oe(o) {\n  let r = fe(ie);\n  if (r === null) {\n    let e = new Error(`<${o} /> is missing a parent <Combobox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(e, oe), e;\n  }\n  return r;\n}\nfunction Eo(o, r) {\n  return ee(r.type, Ao, o, r);\n}\nlet _o = Re;\nfunction ho(o, r) {\n  var ge, ve;\n  let e = no(),\n    {\n      value: t,\n      defaultValue: c,\n      onChange: d,\n      form: f,\n      name: s,\n      by: u,\n      disabled: a = e || !1,\n      onClose: n,\n      __demoMode: T = !1,\n      multiple: C = !1,\n      immediate: _ = !1,\n      virtual: p = null,\n      nullable: L,\n      ...M\n    } = o,\n    F = Ke(c),\n    [v = C ? [] : void 0, y] = ze(t, d, F),\n    [A, R] = Ue(Eo, {\n      dataRef: Ne(),\n      comboboxState: T ? 0 : 1,\n      isTyping: !1,\n      options: [],\n      virtual: p ? {\n        options: p.options,\n        disabled: (ge = p.disabled) != null ? ge : () => !1\n      } : null,\n      activeOptionIndex: null,\n      activationTrigger: 2,\n      __demoMode: T\n    }),\n    h = $(!1),\n    O = $({\n      static: !1,\n      hold: !1\n    }),\n    G = $(null),\n    J = $(null),\n    Q = $(null),\n    I = je(u),\n    B = m(b => p ? u === null ? p.options.indexOf(b) : p.options.findIndex(g => I(g, b)) : A.options.findIndex(g => I(g.dataRef.current.value, b))),\n    k = Se(b => ee(i.mode, {\n      [1]: () => v.some(g => I(g, b)),\n      [0]: () => I(v, b)\n    }), [v]),\n    K = m(b => A.activeOptionIndex === B(b)),\n    i = z(() => ({\n      ...A,\n      immediate: _,\n      optionsPropsRef: O,\n      inputRef: G,\n      buttonRef: J,\n      optionsRef: Q,\n      value: v,\n      defaultValue: F,\n      disabled: a,\n      mode: C ? 1 : 0,\n      virtual: p ? A.virtual : null,\n      get activeOptionIndex() {\n        if (h.current && A.activeOptionIndex === null && (p ? p.options.length > 0 : A.options.length > 0)) {\n          if (p) {\n            let g = p.options.findIndex(j => {\n              var ue, Oe;\n              return !((Oe = (ue = p.disabled) == null ? void 0 : ue.call(p, j)) != null && Oe);\n            });\n            if (g !== -1) return g;\n          }\n          let b = A.options.findIndex(g => !g.dataRef.current.disabled);\n          if (b !== -1) return b;\n        }\n        return A.activeOptionIndex;\n      },\n      calculateIndex: B,\n      compare: I,\n      isSelected: k,\n      isActive: K\n    }), [v, F, a, C, T, A, p]);\n  X(() => {\n    var b;\n    p && R({\n      type: 7,\n      options: p.options,\n      disabled: (b = p.disabled) != null ? b : null\n    });\n  }, [p, p == null ? void 0 : p.options, p == null ? void 0 : p.disabled]), X(() => {\n    A.dataRef.current = i;\n  }, [i]);\n  let N = i.comboboxState === 0;\n  qe(N, [i.buttonRef, i.inputRef, i.optionsRef], () => x.closeCombobox());\n  let q = z(() => {\n      var b, g, j;\n      return {\n        open: i.comboboxState === 0,\n        disabled: a,\n        activeIndex: i.activeOptionIndex,\n        activeOption: i.activeOptionIndex === null ? null : i.virtual ? i.virtual.options[(b = i.activeOptionIndex) != null ? b : 0] : (j = (g = i.options[i.activeOptionIndex]) == null ? void 0 : g.dataRef.current.value) != null ? j : null,\n        value: v\n      };\n    }, [i, a, v]),\n    Y = m(() => {\n      if (i.activeOptionIndex !== null) {\n        if (x.setIsTyping(!1), i.virtual) S(i.virtual.options[i.activeOptionIndex]);else {\n          let {\n            dataRef: b\n          } = i.options[i.activeOptionIndex];\n          S(b.current.value);\n        }\n        x.goToOption(P.Specific, i.activeOptionIndex);\n      }\n    }),\n    E = m(() => {\n      R({\n        type: 0\n      }), h.current = !0;\n    }),\n    ae = m(() => {\n      R({\n        type: 1\n      }), h.current = !1, n == null || n();\n    }),\n    le = m(b => {\n      R({\n        type: 3,\n        isTyping: b\n      });\n    }),\n    l = m((b, g, j) => (h.current = !1, b === P.Specific ? R({\n      type: 2,\n      focus: P.Specific,\n      idx: g,\n      trigger: j\n    }) : R({\n      type: 2,\n      focus: b,\n      trigger: j\n    }))),\n    U = m((b, g) => (R({\n      type: 4,\n      payload: {\n        id: b,\n        dataRef: g\n      }\n    }), () => {\n      i.isActive(g.current.value) && (h.current = !0), R({\n        type: 5,\n        id: b\n      });\n    })),\n    S = m(b => ee(i.mode, {\n      [0]() {\n        return y == null ? void 0 : y(b);\n      },\n      [1]() {\n        let g = i.value.slice(),\n          j = g.findIndex(ue => I(ue, b));\n        return j === -1 ? g.push(b) : g.splice(j, 1), y == null ? void 0 : y(g);\n      }\n    })),\n    H = m(b => {\n      R({\n        type: 6,\n        trigger: b\n      });\n    }),\n    x = z(() => ({\n      onChange: S,\n      registerOption: U,\n      goToOption: l,\n      setIsTyping: le,\n      closeCombobox: ae,\n      openCombobox: E,\n      setActivationTrigger: H,\n      selectActiveOption: Y\n    }), []),\n    [w, W] = Oo(),\n    we = r === null ? {} : {\n      ref: r\n    },\n    Be = Se(() => {\n      if (F !== void 0) return y == null ? void 0 : y(F);\n    }, [y, F]);\n  return D.createElement(W, {\n    value: w,\n    props: {\n      htmlFor: (ve = i.inputRef.current) == null ? void 0 : ve.id\n    },\n    slot: {\n      open: i.comboboxState === 0,\n      disabled: a\n    }\n  }, D.createElement(ro, null, D.createElement(xe.Provider, {\n    value: x\n  }, D.createElement(ie.Provider, {\n    value: i\n  }, D.createElement(fo, {\n    value: ee(i.comboboxState, {\n      [0]: de.Open,\n      [1]: de.Closed\n    })\n  }, s != null && D.createElement(po, {\n    disabled: a,\n    data: v != null ? {\n      [s]: v\n    } : {},\n    form: f,\n    onReset: Be\n  }), ne({\n    ourProps: we,\n    theirProps: M,\n    slot: q,\n    defaultTag: _o,\n    name: \"Combobox\"\n  }))))));\n}\nlet Do = \"input\";\nfunction Mo(o, r) {\n  var q, Y, E, ae, le;\n  let e = oe(\"Combobox.Input\"),\n    t = re(\"Combobox.Input\"),\n    c = pe(),\n    d = bo(),\n    {\n      id: f = d || `headlessui-combobox-input-${c}`,\n      onChange: s,\n      displayValue: u,\n      disabled: a = e.disabled || !1,\n      autoFocus: n = !1,\n      type: T = \"text\",\n      ...C\n    } = o,\n    _ = se(e.inputRef, r, lo()),\n    p = Ae(e.inputRef),\n    L = We(),\n    M = m(() => {\n      t.onChange(null), e.optionsRef.current && (e.optionsRef.current.scrollTop = 0), t.goToOption(P.Nothing);\n    }),\n    F = z(() => {\n      var l;\n      return typeof u == \"function\" && e.value !== void 0 ? (l = u(e.value)) != null ? l : \"\" : typeof e.value == \"string\" ? e.value : \"\";\n    }, [e.value, u]);\n  Ee(([l, U], [S, H]) => {\n    if (e.isTyping) return;\n    let x = e.inputRef.current;\n    x && ((H === 0 && U === 1 || l !== S) && (x.value = l), requestAnimationFrame(() => {\n      if (e.isTyping || !x || (p == null ? void 0 : p.activeElement) !== x) return;\n      let {\n        selectionStart: w,\n        selectionEnd: W\n      } = x;\n      Math.abs((W != null ? W : 0) - (w != null ? w : 0)) === 0 && w === 0 && x.setSelectionRange(x.value.length, x.value.length);\n    }));\n  }, [F, e.comboboxState, p, e.isTyping]), Ee(([l], [U]) => {\n    if (l === 0 && U === 1) {\n      if (e.isTyping) return;\n      let S = e.inputRef.current;\n      if (!S) return;\n      let H = S.value,\n        {\n          selectionStart: x,\n          selectionEnd: w,\n          selectionDirection: W\n        } = S;\n      S.value = \"\", S.value = H, W !== null ? S.setSelectionRange(x, w, W) : S.setSelectionRange(x, w);\n    }\n  }, [e.comboboxState]);\n  let v = $(!1),\n    y = m(() => {\n      v.current = !0;\n    }),\n    A = m(() => {\n      L.nextFrame(() => {\n        v.current = !1;\n      });\n    }),\n    R = m(l => {\n      switch (t.setIsTyping(!0), l.key) {\n        case V.Enter:\n          if (e.comboboxState !== 0 || v.current) return;\n          if (l.preventDefault(), l.stopPropagation(), e.activeOptionIndex === null) {\n            t.closeCombobox();\n            return;\n          }\n          t.selectActiveOption(), e.mode === 0 && t.closeCombobox();\n          break;\n        case V.ArrowDown:\n          return l.preventDefault(), l.stopPropagation(), ee(e.comboboxState, {\n            [0]: () => t.goToOption(P.Next),\n            [1]: () => t.openCombobox()\n          });\n        case V.ArrowUp:\n          return l.preventDefault(), l.stopPropagation(), ee(e.comboboxState, {\n            [0]: () => t.goToOption(P.Previous),\n            [1]: () => {\n              Z(() => t.openCombobox()), e.value || t.goToOption(P.Last);\n            }\n          });\n        case V.Home:\n          if (l.shiftKey) break;\n          return l.preventDefault(), l.stopPropagation(), t.goToOption(P.First);\n        case V.PageUp:\n          return l.preventDefault(), l.stopPropagation(), t.goToOption(P.First);\n        case V.End:\n          if (l.shiftKey) break;\n          return l.preventDefault(), l.stopPropagation(), t.goToOption(P.Last);\n        case V.PageDown:\n          return l.preventDefault(), l.stopPropagation(), t.goToOption(P.Last);\n        case V.Escape:\n          return e.comboboxState !== 0 ? void 0 : (l.preventDefault(), e.optionsRef.current && !e.optionsPropsRef.current.static && l.stopPropagation(), e.mode === 0 && e.value === null && M(), t.closeCombobox());\n        case V.Tab:\n          if (e.comboboxState !== 0) return;\n          e.mode === 0 && e.activationTrigger !== 1 && t.selectActiveOption(), t.closeCombobox();\n          break;\n      }\n    }),\n    h = m(l => {\n      s == null || s(l), e.mode === 0 && l.target.value === \"\" && M(), t.openCombobox();\n    }),\n    O = m(l => {\n      var S, H, x;\n      let U = (S = l.relatedTarget) != null ? S : he.find(w => w !== l.currentTarget);\n      if (!((H = e.optionsRef.current) != null && H.contains(U)) && !((x = e.buttonRef.current) != null && x.contains(U)) && e.comboboxState === 0) return l.preventDefault(), e.mode === 0 && e.value === null && M(), t.closeCombobox();\n    }),\n    G = m(l => {\n      var S, H, x;\n      let U = (S = l.relatedTarget) != null ? S : he.find(w => w !== l.currentTarget);\n      (H = e.buttonRef.current) != null && H.contains(U) || (x = e.optionsRef.current) != null && x.contains(U) || e.disabled || e.immediate && e.comboboxState !== 0 && L.microTask(() => {\n        Z(() => t.openCombobox()), t.setActivationTrigger(1);\n      });\n    }),\n    J = me(),\n    Q = go(),\n    {\n      isFocused: I,\n      focusProps: B\n    } = ye({\n      autoFocus: n\n    }),\n    {\n      isHovered: k,\n      hoverProps: K\n    } = Ce({\n      isDisabled: a\n    }),\n    i = z(() => ({\n      open: e.comboboxState === 0,\n      disabled: a,\n      hover: k,\n      focus: I,\n      autofocus: n\n    }), [e, k, I, n, a]),\n    N = ce({\n      ref: _,\n      id: f,\n      role: \"combobox\",\n      type: T,\n      \"aria-controls\": (q = e.optionsRef.current) == null ? void 0 : q.id,\n      \"aria-expanded\": e.comboboxState === 0,\n      \"aria-activedescendant\": e.activeOptionIndex === null ? void 0 : e.virtual ? (Y = e.options.find(l => !l.dataRef.current.disabled && e.compare(l.dataRef.current.value, e.virtual.options[e.activeOptionIndex]))) == null ? void 0 : Y.id : (E = e.options[e.activeOptionIndex]) == null ? void 0 : E.id,\n      \"aria-labelledby\": J,\n      \"aria-describedby\": Q,\n      \"aria-autocomplete\": \"list\",\n      defaultValue: (le = (ae = o.defaultValue) != null ? ae : e.defaultValue !== void 0 ? u == null ? void 0 : u(e.defaultValue) : null) != null ? le : e.defaultValue,\n      disabled: a || void 0,\n      autoFocus: n,\n      onCompositionStart: y,\n      onCompositionEnd: A,\n      onKeyDown: R,\n      onChange: h,\n      onFocus: G,\n      onBlur: O\n    }, B, K);\n  return ne({\n    ourProps: N,\n    theirProps: C,\n    slot: i,\n    defaultTag: Do,\n    name: \"Combobox.Input\"\n  });\n}\nlet Fo = \"button\";\nfunction Vo(o, r) {\n  var h;\n  let e = oe(\"Combobox.Button\"),\n    t = re(\"Combobox.Button\"),\n    c = se(e.buttonRef, r),\n    d = pe(),\n    {\n      id: f = `headlessui-combobox-button-${d}`,\n      disabled: s = e.disabled || !1,\n      autoFocus: u = !1,\n      ...a\n    } = o,\n    n = Ie(e.inputRef),\n    T = m(O => {\n      switch (O.key) {\n        case V.Space:\n        case V.Enter:\n          O.preventDefault(), O.stopPropagation(), e.comboboxState === 1 && Z(() => t.openCombobox()), n();\n          return;\n        case V.ArrowDown:\n          O.preventDefault(), O.stopPropagation(), e.comboboxState === 1 && (Z(() => t.openCombobox()), e.value || t.goToOption(P.First)), n();\n          return;\n        case V.ArrowUp:\n          O.preventDefault(), O.stopPropagation(), e.comboboxState === 1 && (Z(() => t.openCombobox()), e.value || t.goToOption(P.Last)), n();\n          return;\n        case V.Escape:\n          if (e.comboboxState !== 0) return;\n          O.preventDefault(), e.optionsRef.current && !e.optionsPropsRef.current.static && O.stopPropagation(), Z(() => t.closeCombobox()), n();\n          return;\n        default:\n          return;\n      }\n    }),\n    C = m(O => {\n      O.preventDefault(), !mo(O.currentTarget) && (O.button === Ve.Left && (e.comboboxState === 0 ? t.closeCombobox() : t.openCombobox()), n());\n    }),\n    _ = me([f]),\n    {\n      isFocusVisible: p,\n      focusProps: L\n    } = ye({\n      autoFocus: u\n    }),\n    {\n      isHovered: M,\n      hoverProps: F\n    } = Ce({\n      isDisabled: s\n    }),\n    {\n      pressed: v,\n      pressProps: y\n    } = Ge({\n      disabled: s\n    }),\n    A = z(() => ({\n      open: e.comboboxState === 0,\n      active: v || e.comboboxState === 0,\n      disabled: s,\n      value: e.value,\n      hover: M,\n      focus: p\n    }), [e, M, p, v, s]),\n    R = ce({\n      ref: c,\n      id: f,\n      type: Ye(o, e.buttonRef),\n      tabIndex: -1,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-controls\": (h = e.optionsRef.current) == null ? void 0 : h.id,\n      \"aria-expanded\": e.comboboxState === 0,\n      \"aria-labelledby\": _,\n      disabled: s || void 0,\n      autoFocus: u,\n      onMouseDown: C,\n      onKeyDown: T\n    }, L, F, y);\n  return ne({\n    ourProps: R,\n    theirProps: a,\n    slot: A,\n    defaultTag: Fo,\n    name: \"Combobox.Button\"\n  });\n}\nlet Lo = \"div\",\n  wo = Fe.RenderStrategy | Fe.Static;\nfunction Bo(o, r) {\n  var N, q, Y;\n  let e = pe(),\n    {\n      id: t = `headlessui-combobox-options-${e}`,\n      hold: c = !1,\n      anchor: d,\n      portal: f = !1,\n      modal: s = !0,\n      transition: u = !1,\n      ...a\n    } = o,\n    n = oe(\"Combobox.Options\"),\n    T = re(\"Combobox.Options\"),\n    C = uo(d);\n  C && (f = !0);\n  let [_, p] = io(C),\n    L = ao(),\n    M = se(n.optionsRef, r, C ? _ : null),\n    F = Ae(n.optionsRef),\n    v = co(),\n    [y, A] = oo(u, n.optionsRef, v !== null ? (v & de.Open) === de.Open : n.comboboxState === 0);\n  Je(y, n.inputRef, T.closeCombobox);\n  let R = n.__demoMode ? !1 : s && n.comboboxState === 0;\n  Qe(R, F);\n  let h = n.__demoMode ? !1 : s && n.comboboxState === 0;\n  $e(h, {\n    allowed: m(() => [n.inputRef.current, n.buttonRef.current, n.optionsRef.current])\n  }), X(() => {\n    var E;\n    n.optionsPropsRef.current.static = (E = o.static) != null ? E : !1;\n  }, [n.optionsPropsRef, o.static]), X(() => {\n    n.optionsPropsRef.current.hold = c;\n  }, [n.optionsPropsRef, c]), to(n.comboboxState === 0, {\n    container: n.optionsRef.current,\n    accept(E) {\n      return E.getAttribute(\"role\") === \"option\" ? NodeFilter.FILTER_REJECT : E.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    },\n    walk(E) {\n      E.setAttribute(\"role\", \"none\");\n    }\n  });\n  let O = me([(N = n.buttonRef.current) == null ? void 0 : N.id]),\n    G = z(() => ({\n      open: n.comboboxState === 0,\n      option: void 0\n    }), [n.comboboxState]),\n    J = m(() => {\n      T.setActivationTrigger(0);\n    }),\n    Q = m(E => {\n      E.preventDefault(), T.setActivationTrigger(0);\n    }),\n    I = ce(C ? L() : {}, {\n      \"aria-labelledby\": O,\n      role: \"listbox\",\n      \"aria-multiselectable\": n.mode === 1 ? !0 : void 0,\n      id: t,\n      ref: M,\n      style: {\n        ...a.style,\n        ...p,\n        \"--input-width\": Pe(n.inputRef, !0).width,\n        \"--button-width\": Pe(n.buttonRef, !0).width\n      },\n      onWheel: n.activationTrigger === 0 ? void 0 : J,\n      onMouseDown: Q,\n      ...eo(A)\n    }),\n    B = y && n.comboboxState === 1,\n    k = _e(B, (q = n.virtual) == null ? void 0 : q.options),\n    K = _e(B, n.value),\n    i = m(E => n.compare(K, E));\n  if (n.virtual) {\n    if (k === void 0) throw new Error(\"Missing `options` in virtual mode\");\n    Object.assign(a, {\n      children: D.createElement(ie.Provider, {\n        value: k !== n.virtual.options ? {\n          ...n,\n          virtual: {\n            ...n.virtual,\n            options: k\n          }\n        } : n\n      }, D.createElement(Io, {\n        slot: G\n      }, a.children))\n    });\n  }\n  return D.createElement(yo, {\n    enabled: f ? o.static || y : !1\n  }, D.createElement(ie.Provider, {\n    value: n.mode === 1 ? n : {\n      ...n,\n      isSelected: i\n    }\n  }, ne({\n    ourProps: I,\n    theirProps: {\n      ...a,\n      children: D.createElement(so, {\n        freeze: B\n      }, typeof a.children == \"function\" ? (Y = a.children) == null ? void 0 : Y.call(a, G) : a.children)\n    },\n    slot: G,\n    defaultTag: Lo,\n    features: wo,\n    visible: y,\n    name: \"Combobox.Options\"\n  })));\n}\nlet ko = \"div\";\nfunction No(o, r) {\n  var I, B, k, K;\n  let e = oe(\"Combobox.Option\"),\n    t = re(\"Combobox.Option\"),\n    c = pe(),\n    {\n      id: d = `headlessui-combobox-option-${c}`,\n      value: f,\n      disabled: s = (k = (B = (I = e.virtual) == null ? void 0 : I.disabled) == null ? void 0 : B.call(I, f)) != null ? k : !1,\n      order: u = null,\n      ...a\n    } = o,\n    n = Ie(e.inputRef),\n    T = e.virtual ? e.activeOptionIndex === e.calculateIndex(f) : e.activeOptionIndex === null ? !1 : ((K = e.options[e.activeOptionIndex]) == null ? void 0 : K.id) === d,\n    C = e.isSelected(f),\n    _ = $(null),\n    p = Xe({\n      disabled: s,\n      value: f,\n      domRef: _,\n      order: u\n    }),\n    L = fe(Le),\n    M = se(r, _, L ? L.measureElement : null),\n    F = m(() => {\n      t.setIsTyping(!1), t.onChange(f);\n    });\n  X(() => t.registerOption(d, p), [p, d]);\n  let v = $(!(e.virtual || e.__demoMode));\n  X(() => {\n    if (!e.virtual && !e.__demoMode) return Me().requestAnimationFrame(() => {\n      v.current = !0;\n    });\n  }, [e.virtual, e.__demoMode]), X(() => {\n    if (v.current && e.comboboxState === 0 && T && e.activationTrigger !== 0) return Me().requestAnimationFrame(() => {\n      var i, N;\n      (N = (i = _.current) == null ? void 0 : i.scrollIntoView) == null || N.call(i, {\n        block: \"nearest\"\n      });\n    });\n  }, [_, T, e.comboboxState, e.activationTrigger, e.activeOptionIndex]);\n  let y = m(i => {\n      i.preventDefault(), i.button === Ve.Left && (s || (F(), xo() || requestAnimationFrame(() => n()), e.mode === 0 && t.closeCombobox()));\n    }),\n    A = m(() => {\n      if (s) return t.goToOption(P.Nothing);\n      let i = e.calculateIndex(f);\n      t.goToOption(P.Specific, i);\n    }),\n    R = Ze(),\n    h = m(i => R.update(i)),\n    O = m(i => {\n      if (!R.wasMoved(i) || s || T) return;\n      let N = e.calculateIndex(f);\n      t.goToOption(P.Specific, N, 0);\n    }),\n    G = m(i => {\n      R.wasMoved(i) && (s || T && (e.optionsPropsRef.current.hold || t.goToOption(P.Nothing)));\n    }),\n    J = z(() => ({\n      active: T,\n      focus: T,\n      selected: C,\n      disabled: s\n    }), [T, C, s]);\n  return ne({\n    ourProps: {\n      id: d,\n      ref: M,\n      role: \"option\",\n      tabIndex: s === !0 ? void 0 : -1,\n      \"aria-disabled\": s === !0 ? !0 : void 0,\n      \"aria-selected\": C,\n      disabled: void 0,\n      onMouseDown: y,\n      onFocus: A,\n      onPointerEnter: h,\n      onMouseEnter: h,\n      onPointerMove: O,\n      onMouseMove: O,\n      onPointerLeave: G,\n      onMouseLeave: G\n    },\n    theirProps: a,\n    slot: J,\n    defaultTag: ko,\n    name: \"Combobox.Option\"\n  });\n}\nlet Uo = te(ho),\n  Ho = te(Vo),\n  Go = te(Mo),\n  jo = vo,\n  zo = te(Bo),\n  Ko = te(No),\n  Nt = Object.assign(Uo, {\n    Input: Go,\n    Button: Ho,\n    Label: jo,\n    Options: zo,\n    Option: Ko\n  });\nexport { Nt as Combobox, Ho as ComboboxButton, Go as ComboboxInput, jo as ComboboxLabel, Ko as ComboboxOption, zo as ComboboxOptions };","map":null,"metadata":{},"sourceType":"module"}