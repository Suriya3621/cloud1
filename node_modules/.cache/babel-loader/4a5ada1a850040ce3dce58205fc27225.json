{"ast":null,"code":"\"use client\";\n\nimport d, { Fragment as O, createContext as ee, useContext as W, useEffect as pe, useMemo as te, useRef as v, useState as k } from \"react\";\nimport { useDisposables as Ce } from '../../hooks/use-disposables.js';\nimport { useEvent as b } from '../../hooks/use-event.js';\nimport { useIsMounted as he } from '../../hooks/use-is-mounted.js';\nimport { useIsoMorphicEffect as H } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as ge } from '../../hooks/use-latest-value.js';\nimport { useOnDisappear as ve } from '../../hooks/use-on-disappear.js';\nimport { useServerHandoffComplete as ne } from '../../hooks/use-server-handoff-complete.js';\nimport { useSyncRefs as ie } from '../../hooks/use-sync-refs.js';\nimport { transitionDataAttributes as be, useTransition as Se } from '../../hooks/use-transition.js';\nimport { OpenClosedProvider as Ee, State as N, useOpenClosed as re } from '../../internal/open-closed.js';\nimport { classNames as ye } from '../../utils/class-names.js';\nimport { match as oe } from '../../utils/match.js';\nimport { RenderFeatures as Re, RenderStrategy as P, compact as Pe, forwardRefWithAs as q, render as se } from '../../utils/render.js';\nfunction le(e) {\n  var t;\n  return !!(e.enter || e.enterFrom || e.enterTo || e.leave || e.leaveFrom || e.leaveTo) || ((t = e.as) != null ? t : ue) !== O || d.Children.count(e.children) === 1;\n}\nlet V = ee(null);\nV.displayName = \"TransitionContext\";\nvar xe = (i => (i.Visible = \"visible\", i.Hidden = \"hidden\", i))(xe || {});\nfunction Ne() {\n  let e = W(V);\n  if (e === null) throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  return e;\n}\nfunction _e() {\n  let e = W(w);\n  if (e === null) throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  return e;\n}\nlet w = ee(null);\nw.displayName = \"NestingContext\";\nfunction M(e) {\n  return \"children\" in e ? M(e.children) : e.current.filter(({\n    el: t\n  }) => t.current !== null).filter(({\n    state: t\n  }) => t === \"visible\").length > 0;\n}\nfunction ae(e, t) {\n  let i = ge(e),\n    l = v([]),\n    S = he(),\n    E = Ce(),\n    u = b((s, r = P.Hidden) => {\n      let n = l.current.findIndex(({\n        el: o\n      }) => o === s);\n      n !== -1 && (oe(r, {\n        [P.Unmount]() {\n          l.current.splice(n, 1);\n        },\n        [P.Hidden]() {\n          l.current[n].state = \"hidden\";\n        }\n      }), E.microTask(() => {\n        var o;\n        !M(l) && S.current && ((o = i.current) == null || o.call(i));\n      }));\n    }),\n    y = b(s => {\n      let r = l.current.find(({\n        el: n\n      }) => n === s);\n      return r ? r.state !== \"visible\" && (r.state = \"visible\") : l.current.push({\n        el: s,\n        state: \"visible\"\n      }), () => u(s, P.Unmount);\n    }),\n    c = v([]),\n    f = v(Promise.resolve()),\n    p = v({\n      enter: [],\n      leave: []\n    }),\n    m = b((s, r, n) => {\n      c.current.splice(0), t && (t.chains.current[r] = t.chains.current[r].filter(([o]) => o !== s)), t == null || t.chains.current[r].push([s, new Promise(o => {\n        c.current.push(o);\n      })]), t == null || t.chains.current[r].push([s, new Promise(o => {\n        Promise.all(p.current[r].map(([R, x]) => x)).then(() => o());\n      })]), r === \"enter\" ? f.current = f.current.then(() => t == null ? void 0 : t.wait.current).then(() => n(r)) : n(r);\n    }),\n    C = b((s, r, n) => {\n      Promise.all(p.current[r].splice(0).map(([o, R]) => R)).then(() => {\n        var o;\n        (o = c.current.shift()) == null || o();\n      }).then(() => n(r));\n    });\n  return te(() => ({\n    children: l,\n    register: y,\n    unregister: u,\n    onStart: m,\n    onStop: C,\n    wait: f,\n    chains: p\n  }), [y, u, l, m, C, p, f]);\n}\nlet ue = O,\n  Te = Re.RenderStrategy;\nfunction De(e, t) {\n  var Z, $;\n  let {\n      transition: i = !0,\n      beforeEnter: l,\n      afterEnter: S,\n      beforeLeave: E,\n      afterLeave: u,\n      enter: y,\n      enterFrom: c,\n      enterTo: f,\n      entered: p,\n      leave: m,\n      leaveFrom: C,\n      leaveTo: s,\n      ...r\n    } = e,\n    n = v(null),\n    o = le(e),\n    R = ie(...(o ? [n, t] : t === null ? [] : [t])),\n    x = (Z = r.unmount) == null || Z ? P.Unmount : P.Hidden,\n    {\n      show: T,\n      appear: h,\n      initial: X\n    } = Ne(),\n    [g, U] = k(T ? \"visible\" : \"hidden\"),\n    z = _e(),\n    {\n      register: A,\n      unregister: I\n    } = z;\n  H(() => A(n), [A, n]), H(() => {\n    if (x === P.Hidden && n.current) {\n      if (T && g !== \"visible\") {\n        U(\"visible\");\n        return;\n      }\n      return oe(g, {\n        [\"hidden\"]: () => I(n),\n        [\"visible\"]: () => A(n)\n      });\n    }\n  }, [g, n, A, I, T, x]);\n  let j = ne();\n  H(() => {\n    if (o && j && g === \"visible\" && n.current === null) throw new Error(\"Did you forget to passthrough the `ref` to the actual DOM node?\");\n  }, [n, g, j, o]);\n  let fe = X && !h,\n    K = h && T && X,\n    G = v(!1),\n    F = ae(() => {\n      G.current || (U(\"hidden\"), I(n));\n    }, z),\n    Q = b(B => {\n      G.current = !0;\n      let L = B ? \"enter\" : \"leave\";\n      F.onStart(n, L, D => {\n        D === \"enter\" ? l == null || l() : D === \"leave\" && (E == null || E());\n      });\n    }),\n    Y = b(B => {\n      let L = B ? \"enter\" : \"leave\";\n      G.current = !1, F.onStop(n, L, D => {\n        D === \"enter\" ? S == null || S() : D === \"leave\" && (u == null || u());\n      }), L === \"leave\" && !M(F) && (U(\"hidden\"), I(n));\n    });\n  pe(() => {\n    o && i || (Q(T), Y(T));\n  }, [T, o, i]);\n  let me = (() => !(!i || !o || !j || fe))(),\n    [, a] = Se(me, n, T, {\n      start: Q,\n      end: Y\n    }),\n    ce = Pe({\n      ref: R,\n      className: (($ = ye(r.className, K && y, K && c, a.enter && y, a.enter && a.closed && c, a.enter && !a.closed && f, a.leave && m, a.leave && !a.closed && C, a.leave && a.closed && s, !a.transition && T && p)) == null ? void 0 : $.trim()) || void 0,\n      ...be(a)\n    }),\n    _ = 0;\n  return g === \"visible\" && (_ |= N.Open), g === \"hidden\" && (_ |= N.Closed), a.enter && (_ |= N.Opening), a.leave && (_ |= N.Closing), d.createElement(w.Provider, {\n    value: F\n  }, d.createElement(Ee, {\n    value: _\n  }, se({\n    ourProps: ce,\n    theirProps: r,\n    defaultTag: ue,\n    features: Te,\n    visible: g === \"visible\",\n    name: \"Transition.Child\"\n  })));\n}\nfunction He(e, t) {\n  let {\n      show: i,\n      appear: l = !1,\n      unmount: S = !0,\n      ...E\n    } = e,\n    u = v(null),\n    y = le(e),\n    c = ie(...(y ? [u, t] : t === null ? [] : [t]));\n  ne();\n  let f = re();\n  if (i === void 0 && f !== null && (i = (f & N.Open) === N.Open), i === void 0) throw new Error(\"A <Transition /> is used but it is missing a `show={true | false}` prop.\");\n  let [p, m] = k(i ? \"visible\" : \"hidden\"),\n    C = ae(() => {\n      i || m(\"hidden\");\n    }),\n    [s, r] = k(!0),\n    n = v([i]);\n  H(() => {\n    s !== !1 && n.current[n.current.length - 1] !== i && (n.current.push(i), r(!1));\n  }, [n, i]);\n  let o = te(() => ({\n    show: i,\n    appear: l,\n    initial: s\n  }), [i, l, s]);\n  ve(i, u, () => m(\"hidden\")), H(() => {\n    i ? m(\"visible\") : !M(C) && u.current !== null && m(\"hidden\");\n  }, [i, C]);\n  let R = {\n      unmount: S\n    },\n    x = b(() => {\n      var h;\n      s && r(!1), (h = e.beforeEnter) == null || h.call(e);\n    }),\n    T = b(() => {\n      var h;\n      s && r(!1), (h = e.beforeLeave) == null || h.call(e);\n    });\n  return d.createElement(w.Provider, {\n    value: C\n  }, d.createElement(V.Provider, {\n    value: o\n  }, se({\n    ourProps: {\n      ...R,\n      as: O,\n      children: d.createElement(de, {\n        ref: c,\n        ...R,\n        ...E,\n        beforeEnter: x,\n        beforeLeave: T\n      })\n    },\n    theirProps: {},\n    defaultTag: O,\n    features: Te,\n    visible: p === \"visible\",\n    name: \"Transition\"\n  })));\n}\nfunction Ae(e, t) {\n  let i = W(V) !== null,\n    l = re() !== null;\n  return d.createElement(d.Fragment, null, !i && l ? d.createElement(J, {\n    ref: t,\n    ...e\n  }) : d.createElement(de, {\n    ref: t,\n    ...e\n  }));\n}\nlet J = q(He),\n  de = q(De),\n  Ie = q(Ae),\n  Xe = Object.assign(J, {\n    Child: Ie,\n    Root: J\n  });\nexport { Xe as Transition, Ie as TransitionChild };","map":null,"metadata":{},"sourceType":"module"}