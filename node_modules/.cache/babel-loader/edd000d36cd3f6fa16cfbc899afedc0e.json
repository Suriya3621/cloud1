{"ast":null,"code":"\"use client\";\n\nimport { useFocusRing as Ae } from \"@react-aria/focus\";\nimport { useHover as Ee } from \"@react-aria/interactions\";\nimport D, { Fragment as ce, createContext as ie, createRef as he, useCallback as fe, useContext as re, useEffect as De, useMemo as k, useReducer as _e, useRef as K } from \"react\";\nimport { flushSync as G } from \"react-dom\";\nimport { useActivePress as Ie } from '../../hooks/use-active-press.js';\nimport { useByComparator as Ce } from '../../hooks/use-by-comparator.js';\nimport { useComputed as Fe } from '../../hooks/use-computed.js';\nimport { useControllable as Me } from '../../hooks/use-controllable.js';\nimport { useDefaultValue as we } from '../../hooks/use-default-value.js';\nimport { useDidElementMove as Be } from '../../hooks/use-did-element-move.js';\nimport { useDisposables as be } from '../../hooks/use-disposables.js';\nimport { useElementSize as ke } from '../../hooks/use-element-size.js';\nimport { useEvent as T } from '../../hooks/use-event.js';\nimport { useId as le } from '../../hooks/use-id.js';\nimport { useInertOthers as Ue } from '../../hooks/use-inert-others.js';\nimport { useIsoMorphicEffect as ae } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as Ne } from '../../hooks/use-latest-value.js';\nimport { useOnDisappear as Ge } from '../../hooks/use-on-disappear.js';\nimport { useOutsideClick as Ve } from '../../hooks/use-outside-click.js';\nimport { useOwnerDocument as He } from '../../hooks/use-owner.js';\nimport { useResolveButtonType as Ke } from '../../hooks/use-resolve-button-type.js';\nimport { useScrollLock as je } from '../../hooks/use-scroll-lock.js';\nimport { useSyncRefs as j } from '../../hooks/use-sync-refs.js';\nimport { useTextValue as ze } from '../../hooks/use-text-value.js';\nimport { useTrackedPointer as We } from '../../hooks/use-tracked-pointer.js';\nimport { transitionDataAttributes as Qe, useTransition as Xe } from '../../hooks/use-transition.js';\nimport { useDisabled as Je } from '../../internal/disabled.js';\nimport { FloatingProvider as $e, useFloatingPanel as qe, useFloatingPanelProps as Ye, useFloatingReference as Ze, useFloatingReferenceProps as et, useResolvedAnchor as tt } from '../../internal/floating.js';\nimport { FormFields as ot } from '../../internal/form-fields.js';\nimport { useFrozenData as nt } from '../../internal/frozen.js';\nimport { useProvidedId as it } from '../../internal/id.js';\nimport { OpenClosedProvider as rt, State as J, useOpenClosed as lt } from '../../internal/open-closed.js';\nimport { isDisabledReactIssue7711 as at } from '../../utils/bugs.js';\nimport { Focus as v, calculateActiveIndex as se } from '../../utils/calculate-active-index.js';\nimport { disposables as st } from '../../utils/disposables.js';\nimport { Focus as Te, FocusableMode as pt, focusFrom as ut, isFocusableElement as dt, sortByDomNode as ct } from '../../utils/focus-management.js';\nimport { attemptSubmit as ft } from '../../utils/form.js';\nimport { match as V } from '../../utils/match.js';\nimport { getOwnerDocument as bt } from '../../utils/owner.js';\nimport { RenderFeatures as xe, forwardRefWithAs as z, mergeProps as me, render as W } from '../../utils/render.js';\nimport { useDescribedBy as Tt } from '../description/description.js';\nimport { Keys as R } from '../keyboard.js';\nimport { Label as xt, useLabelledBy as mt, useLabels as Ot } from '../label/label.js';\nimport { Portal as yt } from '../portal/portal.js';\nvar vt = (o => (o[o.Open = 0] = \"Open\", o[o.Closed = 1] = \"Closed\", o))(vt || {}),\n  gt = (o => (o[o.Single = 0] = \"Single\", o[o.Multi = 1] = \"Multi\", o))(gt || {}),\n  Lt = (o => (o[o.Pointer = 0] = \"Pointer\", o[o.Other = 1] = \"Other\", o))(Lt || {}),\n  St = (i => (i[i.OpenListbox = 0] = \"OpenListbox\", i[i.CloseListbox = 1] = \"CloseListbox\", i[i.GoToOption = 2] = \"GoToOption\", i[i.Search = 3] = \"Search\", i[i.ClearSearch = 4] = \"ClearSearch\", i[i.RegisterOption = 5] = \"RegisterOption\", i[i.UnregisterOption = 6] = \"UnregisterOption\", i))(St || {});\nfunction pe(e, r = o => o) {\n  let o = e.activeOptionIndex !== null ? e.options[e.activeOptionIndex] : null,\n    n = ct(r(e.options.slice()), m => m.dataRef.current.domRef.current),\n    a = o ? n.indexOf(o) : null;\n  return a === -1 && (a = null), {\n    options: n,\n    activeOptionIndex: a\n  };\n}\nlet Rt = {\n    [1](e) {\n      return e.dataRef.current.disabled || e.listboxState === 1 ? e : {\n        ...e,\n        activeOptionIndex: null,\n        listboxState: 1,\n        __demoMode: !1\n      };\n    },\n    [0](e) {\n      if (e.dataRef.current.disabled || e.listboxState === 0) return e;\n      let r = e.activeOptionIndex,\n        {\n          isSelected: o\n        } = e.dataRef.current,\n        n = e.options.findIndex(a => o(a.dataRef.current.value));\n      return n !== -1 && (r = n), {\n        ...e,\n        listboxState: 0,\n        activeOptionIndex: r,\n        __demoMode: !1\n      };\n    },\n    [2](e, r) {\n      var m, O, i, p, s;\n      if (e.dataRef.current.disabled || e.listboxState === 1) return e;\n      let o = {\n        ...e,\n        searchQuery: \"\",\n        activationTrigger: (m = r.trigger) != null ? m : 1,\n        __demoMode: !1\n      };\n      if (r.focus === v.Nothing) return {\n        ...o,\n        activeOptionIndex: null\n      };\n      if (r.focus === v.Specific) return {\n        ...o,\n        activeOptionIndex: e.options.findIndex(t => t.id === r.id)\n      };\n      if (r.focus === v.Previous) {\n        let t = e.activeOptionIndex;\n        if (t !== null) {\n          let u = e.options[t].dataRef.current.domRef,\n            b = se(r, {\n              resolveItems: () => e.options,\n              resolveActiveIndex: () => e.activeOptionIndex,\n              resolveId: c => c.id,\n              resolveDisabled: c => c.dataRef.current.disabled\n            });\n          if (b !== null) {\n            let c = e.options[b].dataRef.current.domRef;\n            if (((O = u.current) == null ? void 0 : O.previousElementSibling) === c.current || ((i = c.current) == null ? void 0 : i.previousElementSibling) === null) return {\n              ...o,\n              activeOptionIndex: b\n            };\n          }\n        }\n      } else if (r.focus === v.Next) {\n        let t = e.activeOptionIndex;\n        if (t !== null) {\n          let u = e.options[t].dataRef.current.domRef,\n            b = se(r, {\n              resolveItems: () => e.options,\n              resolveActiveIndex: () => e.activeOptionIndex,\n              resolveId: c => c.id,\n              resolveDisabled: c => c.dataRef.current.disabled\n            });\n          if (b !== null) {\n            let c = e.options[b].dataRef.current.domRef;\n            if (((p = u.current) == null ? void 0 : p.nextElementSibling) === c.current || ((s = c.current) == null ? void 0 : s.nextElementSibling) === null) return {\n              ...o,\n              activeOptionIndex: b\n            };\n          }\n        }\n      }\n      let n = pe(e),\n        a = se(r, {\n          resolveItems: () => n.options,\n          resolveActiveIndex: () => n.activeOptionIndex,\n          resolveId: t => t.id,\n          resolveDisabled: t => t.dataRef.current.disabled\n        });\n      return {\n        ...o,\n        ...n,\n        activeOptionIndex: a\n      };\n    },\n    [3]: (e, r) => {\n      if (e.dataRef.current.disabled || e.listboxState === 1) return e;\n      let n = e.searchQuery !== \"\" ? 0 : 1,\n        a = e.searchQuery + r.value.toLowerCase(),\n        O = (e.activeOptionIndex !== null ? e.options.slice(e.activeOptionIndex + n).concat(e.options.slice(0, e.activeOptionIndex + n)) : e.options).find(p => {\n          var s;\n          return !p.dataRef.current.disabled && ((s = p.dataRef.current.textValue) == null ? void 0 : s.startsWith(a));\n        }),\n        i = O ? e.options.indexOf(O) : -1;\n      return i === -1 || i === e.activeOptionIndex ? {\n        ...e,\n        searchQuery: a\n      } : {\n        ...e,\n        searchQuery: a,\n        activeOptionIndex: i,\n        activationTrigger: 1\n      };\n    },\n    [4](e) {\n      return e.dataRef.current.disabled || e.listboxState === 1 || e.searchQuery === \"\" ? e : {\n        ...e,\n        searchQuery: \"\"\n      };\n    },\n    [5]: (e, r) => {\n      let o = {\n          id: r.id,\n          dataRef: r.dataRef\n        },\n        n = pe(e, a => [...a, o]);\n      return e.activeOptionIndex === null && e.dataRef.current.isSelected(r.dataRef.current.value) && (n.activeOptionIndex = n.options.indexOf(o)), {\n        ...e,\n        ...n\n      };\n    },\n    [6]: (e, r) => {\n      let o = pe(e, n => {\n        let a = n.findIndex(m => m.id === r.id);\n        return a !== -1 && n.splice(a, 1), n;\n      });\n      return {\n        ...e,\n        ...o,\n        activationTrigger: 1\n      };\n    }\n  },\n  ue = ie(null);\nue.displayName = \"ListboxActionsContext\";\nfunction $(e) {\n  let r = re(ue);\n  if (r === null) {\n    let o = new Error(`<${e} /> is missing a parent <Listbox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, $), o;\n  }\n  return r;\n}\nlet q = ie(null);\nq.displayName = \"ListboxDataContext\";\nfunction Q(e) {\n  let r = re(q);\n  if (r === null) {\n    let o = new Error(`<${e} /> is missing a parent <Listbox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, Q), o;\n  }\n  return r;\n}\nfunction Pt(e, r) {\n  return V(r.type, Rt, e, r);\n}\nlet At = ce;\nfunction Et(e, r) {\n  var de;\n  let o = Je(),\n    {\n      value: n,\n      defaultValue: a,\n      form: m,\n      name: O,\n      onChange: i,\n      by: p,\n      invalid: s = !1,\n      disabled: t = o || !1,\n      horizontal: u = !1,\n      multiple: b = !1,\n      __demoMode: c = !1,\n      ...E\n    } = e;\n  const U = u ? \"horizontal\" : \"vertical\";\n  let N = j(r),\n    _ = we(a),\n    [y = b ? [] : void 0, P] = Me(n, i, _),\n    [h, g] = _e(Pt, {\n      dataRef: he(),\n      listboxState: c ? 0 : 1,\n      options: [],\n      searchQuery: \"\",\n      activeOptionIndex: null,\n      activationTrigger: 1,\n      optionsVisible: !1,\n      __demoMode: c\n    }),\n    M = K({\n      static: !1,\n      hold: !1\n    }),\n    w = K(null),\n    f = K(null),\n    A = K(new Map()),\n    F = Ce(p),\n    L = fe(x => V(d.mode, {\n      [1]: () => y.some(S => F(S, x)),\n      [0]: () => F(y, x)\n    }), [y]),\n    d = k(() => ({\n      ...h,\n      value: y,\n      disabled: t,\n      invalid: s,\n      mode: b ? 1 : 0,\n      orientation: U,\n      compare: F,\n      isSelected: L,\n      optionsPropsRef: M,\n      buttonRef: w,\n      optionsRef: f,\n      listRef: A\n    }), [y, t, s, b, h, A]);\n  ae(() => {\n    h.dataRef.current = d;\n  }, [d]);\n  let Y = d.listboxState === 0;\n  Ve(Y, [d.buttonRef, d.optionsRef], (x, S) => {\n    var C;\n    g({\n      type: 1\n    }), dt(S, pt.Loose) || (x.preventDefault(), (C = d.buttonRef.current) == null || C.focus());\n  });\n  let X = k(() => ({\n      open: d.listboxState === 0,\n      disabled: t,\n      invalid: s,\n      value: y\n    }), [d, t, y, s]),\n    Z = T(x => {\n      let S = d.options.find(C => C.id === x);\n      S && B(S.dataRef.current.value);\n    }),\n    ee = T(() => {\n      if (d.activeOptionIndex !== null) {\n        let {\n          dataRef: x,\n          id: S\n        } = d.options[d.activeOptionIndex];\n        B(x.current.value), g({\n          type: 2,\n          focus: v.Specific,\n          id: S\n        });\n      }\n    }),\n    te = T(() => g({\n      type: 0\n    })),\n    oe = T(() => g({\n      type: 1\n    })),\n    H = be(),\n    l = T((x, S, C) => {\n      H.dispose(), H.microTask(() => x === v.Specific ? g({\n        type: 2,\n        focus: v.Specific,\n        id: S,\n        trigger: C\n      }) : g({\n        type: 2,\n        focus: x,\n        trigger: C\n      }));\n    }),\n    I = T((x, S) => (g({\n      type: 5,\n      id: x,\n      dataRef: S\n    }), () => g({\n      type: 6,\n      id: x\n    }))),\n    B = T(x => V(d.mode, {\n      [0]() {\n        return P == null ? void 0 : P(x);\n      },\n      [1]() {\n        let S = d.value.slice(),\n          C = S.findIndex(Pe => F(Pe, x));\n        return C === -1 ? S.push(x) : S.splice(C, 1), P == null ? void 0 : P(S);\n      }\n    })),\n    ne = T(x => g({\n      type: 3,\n      value: x\n    })),\n    ye = T(() => g({\n      type: 4\n    })),\n    ve = k(() => ({\n      onChange: B,\n      registerOption: I,\n      goToOption: l,\n      closeListbox: oe,\n      openListbox: te,\n      selectActiveOption: ee,\n      selectOption: Z,\n      search: ne,\n      clearSearch: ye\n    }), []),\n    [ge, Le] = Ot({\n      inherit: !0\n    }),\n    Se = {\n      ref: N\n    },\n    Re = fe(() => {\n      if (_ !== void 0) return P == null ? void 0 : P(_);\n    }, [P, _]);\n  return D.createElement(Le, {\n    value: ge,\n    props: {\n      htmlFor: (de = d.buttonRef.current) == null ? void 0 : de.id\n    },\n    slot: {\n      open: d.listboxState === 0,\n      disabled: t\n    }\n  }, D.createElement($e, null, D.createElement(ue.Provider, {\n    value: ve\n  }, D.createElement(q.Provider, {\n    value: d\n  }, D.createElement(rt, {\n    value: V(d.listboxState, {\n      [0]: J.Open,\n      [1]: J.Closed\n    })\n  }, O != null && y != null && D.createElement(ot, {\n    disabled: t,\n    data: {\n      [O]: y\n    },\n    form: m,\n    onReset: Re\n  }), W({\n    ourProps: Se,\n    theirProps: E,\n    slot: X,\n    defaultTag: At,\n    name: \"Listbox\"\n  }))))));\n}\nlet ht = \"button\";\nfunction Dt(e, r) {\n  var F;\n  let o = Q(\"Listbox.Button\"),\n    n = $(\"Listbox.Button\"),\n    a = le(),\n    m = it(),\n    {\n      id: O = m || `headlessui-listbox-button-${a}`,\n      disabled: i = o.disabled || !1,\n      autoFocus: p = !1,\n      ...s\n    } = e,\n    t = j(o.buttonRef, r, Ze()),\n    u = et(),\n    b = T(L => {\n      switch (L.key) {\n        case R.Enter:\n          ft(L.currentTarget);\n          break;\n        case R.Space:\n        case R.ArrowDown:\n          L.preventDefault(), G(() => n.openListbox()), o.value || n.goToOption(v.First);\n          break;\n        case R.ArrowUp:\n          L.preventDefault(), G(() => n.openListbox()), o.value || n.goToOption(v.Last);\n          break;\n      }\n    }),\n    c = T(L => {\n      switch (L.key) {\n        case R.Space:\n          L.preventDefault();\n          break;\n      }\n    }),\n    E = T(L => {\n      var d;\n      if (at(L.currentTarget)) return L.preventDefault();\n      o.listboxState === 0 ? (G(() => n.closeListbox()), (d = o.buttonRef.current) == null || d.focus({\n        preventScroll: !0\n      })) : (L.preventDefault(), n.openListbox());\n    }),\n    U = T(L => L.preventDefault()),\n    N = mt([O]),\n    _ = Tt(),\n    {\n      isFocusVisible: y,\n      focusProps: P\n    } = Ae({\n      autoFocus: p\n    }),\n    {\n      isHovered: h,\n      hoverProps: g\n    } = Ee({\n      isDisabled: i\n    }),\n    {\n      pressed: M,\n      pressProps: w\n    } = Ie({\n      disabled: i\n    }),\n    f = k(() => ({\n      open: o.listboxState === 0,\n      active: M || o.listboxState === 0,\n      disabled: i,\n      invalid: o.invalid,\n      value: o.value,\n      hover: h,\n      focus: y,\n      autofocus: p\n    }), [o.listboxState, o.value, i, h, y, M, o.invalid, p]),\n    A = me(u(), {\n      ref: t,\n      id: O,\n      type: Ke(e, o.buttonRef),\n      \"aria-haspopup\": \"listbox\",\n      \"aria-controls\": (F = o.optionsRef.current) == null ? void 0 : F.id,\n      \"aria-expanded\": o.listboxState === 0,\n      \"aria-labelledby\": N,\n      \"aria-describedby\": _,\n      disabled: i || void 0,\n      autoFocus: p,\n      onKeyDown: b,\n      onKeyUp: c,\n      onKeyPress: U,\n      onClick: E\n    }, P, g, w);\n  return W({\n    ourProps: A,\n    theirProps: s,\n    slot: f,\n    defaultTag: ht,\n    name: \"Listbox.Button\"\n  });\n}\nlet Oe = ie(!1),\n  _t = \"div\",\n  It = xe.RenderStrategy | xe.Static;\nfunction Ct(e, r) {\n  var H;\n  let o = le(),\n    {\n      id: n = `headlessui-listbox-options-${o}`,\n      anchor: a,\n      portal: m = !1,\n      modal: O = !0,\n      transition: i = !1,\n      ...p\n    } = e,\n    s = tt(a);\n  s && (m = !0);\n  let t = Q(\"Listbox.Options\"),\n    u = $(\"Listbox.Options\"),\n    b = He(t.optionsRef),\n    c = lt(),\n    [E, U] = Xe(i, t.optionsRef, c !== null ? (c & J.Open) === J.Open : t.listboxState === 0);\n  Ge(E, t.buttonRef, u.closeListbox);\n  let N = t.__demoMode ? !1 : O && t.listboxState === 0;\n  je(N, b);\n  let _ = t.__demoMode ? !1 : O && t.listboxState === 0;\n  Ue(_, {\n    allowed: T(() => [t.buttonRef.current, t.optionsRef.current])\n  });\n  let y = t.listboxState !== 0,\n    h = Be(y, t.buttonRef) ? !1 : E,\n    g = E && t.listboxState === 1,\n    M = nt(g, t.value),\n    w = T(l => t.compare(M, l)),\n    f = k(() => {\n      var I;\n      if (s == null || !((I = s == null ? void 0 : s.to) != null && I.includes(\"selection\"))) return null;\n      let l = t.options.findIndex(B => w(B.dataRef.current.value));\n      return l === -1 && (l = 0), l;\n    }, [s, t.options]),\n    A = (() => {\n      if (s == null) return;\n      if (f === null) return {\n        ...s,\n        inner: void 0\n      };\n      let l = Array.from(t.listRef.current.values());\n      return {\n        ...s,\n        inner: {\n          listRef: {\n            current: l\n          },\n          index: f\n        }\n      };\n    })(),\n    [F, L] = qe(A),\n    d = Ye(),\n    Y = j(t.optionsRef, r, s ? F : null),\n    X = be();\n  De(() => {\n    var I;\n    let l = t.optionsRef.current;\n    l && t.listboxState === 0 && l !== ((I = bt(l)) == null ? void 0 : I.activeElement) && (l == null || l.focus({\n      preventScroll: !0\n    }));\n  }, [t.listboxState, t.optionsRef, t.optionsRef.current]);\n  let Z = T(l => {\n      var I, B;\n      switch (X.dispose(), l.key) {\n        case R.Space:\n          if (t.searchQuery !== \"\") return l.preventDefault(), l.stopPropagation(), u.search(l.key);\n        case R.Enter:\n          if (l.preventDefault(), l.stopPropagation(), t.activeOptionIndex !== null) {\n            let {\n              dataRef: ne\n            } = t.options[t.activeOptionIndex];\n            u.onChange(ne.current.value);\n          }\n          t.mode === 0 && (G(() => u.closeListbox()), (I = t.buttonRef.current) == null || I.focus({\n            preventScroll: !0\n          }));\n          break;\n        case V(t.orientation, {\n          vertical: R.ArrowDown,\n          horizontal: R.ArrowRight\n        }):\n          return l.preventDefault(), l.stopPropagation(), u.goToOption(v.Next);\n        case V(t.orientation, {\n          vertical: R.ArrowUp,\n          horizontal: R.ArrowLeft\n        }):\n          return l.preventDefault(), l.stopPropagation(), u.goToOption(v.Previous);\n        case R.Home:\n        case R.PageUp:\n          return l.preventDefault(), l.stopPropagation(), u.goToOption(v.First);\n        case R.End:\n        case R.PageDown:\n          return l.preventDefault(), l.stopPropagation(), u.goToOption(v.Last);\n        case R.Escape:\n          l.preventDefault(), l.stopPropagation(), G(() => u.closeListbox()), (B = t.buttonRef.current) == null || B.focus({\n            preventScroll: !0\n          });\n          return;\n        case R.Tab:\n          l.preventDefault(), l.stopPropagation(), G(() => u.closeListbox()), ut(t.buttonRef.current, l.shiftKey ? Te.Previous : Te.Next);\n          break;\n        default:\n          l.key.length === 1 && (u.search(l.key), X.setTimeout(() => u.clearSearch(), 350));\n          break;\n      }\n    }),\n    ee = Fe(() => {\n      var l;\n      return (l = t.buttonRef.current) == null ? void 0 : l.id;\n    }, [t.buttonRef.current]),\n    te = k(() => ({\n      open: t.listboxState === 0\n    }), [t.listboxState]),\n    oe = me(s ? d() : {}, {\n      id: n,\n      ref: Y,\n      \"aria-activedescendant\": t.activeOptionIndex === null || (H = t.options[t.activeOptionIndex]) == null ? void 0 : H.id,\n      \"aria-multiselectable\": t.mode === 1 ? !0 : void 0,\n      \"aria-labelledby\": ee,\n      \"aria-orientation\": t.orientation,\n      onKeyDown: Z,\n      role: \"listbox\",\n      tabIndex: t.listboxState === 0 ? 0 : void 0,\n      style: {\n        ...p.style,\n        ...L,\n        \"--button-width\": ke(t.buttonRef, !0).width\n      },\n      ...Qe(U)\n    });\n  return D.createElement(yt, {\n    enabled: m ? e.static || E : !1\n  }, D.createElement(q.Provider, {\n    value: t.mode === 1 ? t : {\n      ...t,\n      isSelected: w\n    }\n  }, W({\n    ourProps: oe,\n    theirProps: p,\n    slot: te,\n    defaultTag: _t,\n    features: It,\n    visible: h,\n    name: \"Listbox.Options\"\n  })));\n}\nlet Ft = \"div\";\nfunction Mt(e, r) {\n  let o = le(),\n    {\n      id: n = `headlessui-listbox-option-${o}`,\n      disabled: a = !1,\n      value: m,\n      ...O\n    } = e,\n    i = re(Oe) === !0,\n    p = Q(\"Listbox.Option\"),\n    s = $(\"Listbox.Option\"),\n    t = p.activeOptionIndex !== null ? p.options[p.activeOptionIndex].id === n : !1,\n    u = p.isSelected(m),\n    b = K(null),\n    c = ze(b),\n    E = Ne({\n      disabled: a,\n      value: m,\n      domRef: b,\n      get textValue() {\n        return c();\n      }\n    }),\n    U = j(r, b, f => {\n      f ? p.listRef.current.set(n, f) : p.listRef.current.delete(n);\n    });\n  ae(() => {\n    if (!p.__demoMode && p.listboxState === 0 && t && p.activationTrigger !== 0) return st().requestAnimationFrame(() => {\n      var f, A;\n      (A = (f = b.current) == null ? void 0 : f.scrollIntoView) == null || A.call(f, {\n        block: \"nearest\"\n      });\n    });\n  }, [b, t, p.__demoMode, p.listboxState, p.activationTrigger, p.activeOptionIndex]), ae(() => {\n    if (!i) return s.registerOption(n, E);\n  }, [E, n, i]);\n  let N = T(f => {\n      var A;\n      if (a) return f.preventDefault();\n      s.onChange(m), p.mode === 0 && (G(() => s.closeListbox()), (A = p.buttonRef.current) == null || A.focus({\n        preventScroll: !0\n      }));\n    }),\n    _ = T(() => {\n      if (a) return s.goToOption(v.Nothing);\n      s.goToOption(v.Specific, n);\n    }),\n    y = We(),\n    P = T(f => {\n      y.update(f), !a && (t || s.goToOption(v.Specific, n, 0));\n    }),\n    h = T(f => {\n      y.wasMoved(f) && (a || t || s.goToOption(v.Specific, n, 0));\n    }),\n    g = T(f => {\n      y.wasMoved(f) && (a || t && s.goToOption(v.Nothing));\n    }),\n    M = k(() => ({\n      active: t,\n      focus: t,\n      selected: u,\n      disabled: a,\n      selectedOption: u && i\n    }), [t, u, a, i]),\n    w = i ? {} : {\n      id: n,\n      ref: U,\n      role: \"option\",\n      tabIndex: a === !0 ? void 0 : -1,\n      \"aria-disabled\": a === !0 ? !0 : void 0,\n      \"aria-selected\": u,\n      disabled: void 0,\n      onClick: N,\n      onFocus: _,\n      onPointerEnter: P,\n      onMouseEnter: P,\n      onPointerMove: h,\n      onMouseMove: h,\n      onPointerLeave: g,\n      onMouseLeave: g\n    };\n  return !u && i ? null : W({\n    ourProps: w,\n    theirProps: O,\n    slot: M,\n    defaultTag: Ft,\n    name: \"Listbox.Option\"\n  });\n}\nlet wt = ce;\nfunction Bt(e, r) {\n  let {\n      options: o,\n      placeholder: n,\n      ...a\n    } = e,\n    O = {\n      ref: j(r)\n    },\n    i = Q(\"ListboxSelectedOption\"),\n    p = k(() => ({}), []),\n    s = i.value === void 0 || i.value === null || i.mode === 1 && Array.isArray(i.value) && i.value.length === 0;\n  return D.createElement(Oe.Provider, {\n    value: !0\n  }, W({\n    ourProps: O,\n    theirProps: {\n      ...a,\n      children: D.createElement(D.Fragment, null, n && s ? n : o)\n    },\n    slot: p,\n    defaultTag: wt,\n    name: \"ListboxSelectedOption\"\n  }));\n}\nlet kt = z(Et),\n  Ut = z(Dt),\n  Nt = xt,\n  Gt = z(Ct),\n  Vt = z(Mt),\n  Ht = z(Bt),\n  Mo = Object.assign(kt, {\n    Button: Ut,\n    Label: Nt,\n    Options: Gt,\n    Option: Vt,\n    SelectedOption: Ht\n  });\nexport { Mo as Listbox, Ut as ListboxButton, Nt as ListboxLabel, Vt as ListboxOption, Gt as ListboxOptions, Ht as ListboxSelectedOption };","map":null,"metadata":{},"sourceType":"module"}