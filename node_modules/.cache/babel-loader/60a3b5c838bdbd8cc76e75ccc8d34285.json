{"ast":null,"code":"\"use client\";\n\nimport k, { createContext as D, useContext as h, useMemo as T, useState as R } from \"react\";\nimport { useEvent as v } from '../../hooks/use-event.js';\nimport { useId as _ } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as A } from '../../hooks/use-iso-morphic-effect.js';\nimport { useSyncRefs as B } from '../../hooks/use-sync-refs.js';\nimport { useDisabled as F } from '../../internal/disabled.js';\nimport { useProvidedId as S } from '../../internal/id.js';\nimport { forwardRefWithAs as M, render as H } from '../../utils/render.js';\nlet c = D(null);\nc.displayName = \"LabelContext\";\nfunction P() {\n  let r = h(c);\n  if (r === null) {\n    let l = new Error(\"You used a <Label /> component, but it is not inside a relevant parent.\");\n    throw Error.captureStackTrace && Error.captureStackTrace(l, P), l;\n  }\n  return r;\n}\nfunction I(r) {\n  var a, e, o;\n  let l = (e = (a = h(c)) == null ? void 0 : a.value) != null ? e : void 0;\n  return ((o = r == null ? void 0 : r.length) != null ? o : 0) > 0 ? [l, ...r].filter(Boolean).join(\" \") : l;\n}\nfunction z({\n  inherit: r = !1\n} = {}) {\n  let l = I(),\n    [a, e] = R([]),\n    o = r ? [l, ...a].filter(Boolean) : a;\n  return [o.length > 0 ? o.join(\" \") : void 0, T(() => function (t) {\n    let s = v(i => (e(p => [...p, i]), () => e(p => {\n        let u = p.slice(),\n          d = u.indexOf(i);\n        return d !== -1 && u.splice(d, 1), u;\n      }))),\n      m = T(() => ({\n        register: s,\n        slot: t.slot,\n        name: t.name,\n        props: t.props,\n        value: t.value\n      }), [s, t.slot, t.name, t.props, t.value]);\n    return k.createElement(c.Provider, {\n      value: m\n    }, t.children);\n  }, [e])];\n}\nlet N = \"label\";\nfunction G(r, l) {\n  var y;\n  let a = _(),\n    e = P(),\n    o = S(),\n    g = F(),\n    {\n      id: t = `headlessui-label-${a}`,\n      htmlFor: s = o != null ? o : (y = e.props) == null ? void 0 : y.htmlFor,\n      passive: m = !1,\n      ...i\n    } = r,\n    p = B(l);\n  A(() => e.register(t), [t, e.register]);\n  let u = v(L => {\n      let b = L.currentTarget;\n      if (b instanceof HTMLLabelElement && L.preventDefault(), e.props && \"onClick\" in e.props && typeof e.props.onClick == \"function\" && e.props.onClick(L), b instanceof HTMLLabelElement) {\n        let n = document.getElementById(b.htmlFor);\n        if (n) {\n          let E = n.getAttribute(\"disabled\");\n          if (E === \"true\" || E === \"\") return;\n          let x = n.getAttribute(\"aria-disabled\");\n          if (x === \"true\" || x === \"\") return;\n          (n instanceof HTMLInputElement && (n.type === \"radio\" || n.type === \"checkbox\") || n.role === \"radio\" || n.role === \"checkbox\" || n.role === \"switch\") && n.click(), n.focus({\n            preventScroll: !0\n          });\n        }\n      }\n    }),\n    d = g || !1,\n    C = T(() => ({\n      ...e.slot,\n      disabled: d\n    }), [e.slot, d]),\n    f = {\n      ref: p,\n      ...e.props,\n      id: t,\n      htmlFor: s,\n      onClick: u\n    };\n  return m && (\"onClick\" in f && (delete f.htmlFor, delete f.onClick), \"onClick\" in i && delete i.onClick), H({\n    ourProps: f,\n    theirProps: i,\n    slot: C,\n    defaultTag: s ? N : \"div\",\n    name: e.name || \"Label\"\n  });\n}\nlet U = M(G),\n  K = Object.assign(U, {});\nexport { K as Label, P as useLabelContext, I as useLabelledBy, z as useLabels };","map":null,"metadata":{},"sourceType":"module"}