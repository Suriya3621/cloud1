{"ast":null,"code":"\"use client\";\n\nimport { useFocusRing as te } from \"@react-aria/focus\";\nimport { useHover as de } from \"@react-aria/interactions\";\nimport G, { createContext as re, useContext as ne, useMemo as D, useReducer as ce, useRef as q } from \"react\";\nimport { useActivePress as fe } from '../../hooks/use-active-press.js';\nimport { useEvent as S } from '../../hooks/use-event.js';\nimport { useId as ae } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as W } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as j } from '../../hooks/use-latest-value.js';\nimport { useResolveButtonType as be } from '../../hooks/use-resolve-button-type.js';\nimport { useSyncRefs as U } from '../../hooks/use-sync-refs.js';\nimport { FocusSentinel as me } from '../../internal/focus-sentinel.js';\nimport { Hidden as Pe } from '../../internal/hidden.js';\nimport { Focus as P, FocusResult as K, focusIn as v, sortByDomNode as H } from '../../utils/focus-management.js';\nimport { match as w } from '../../utils/match.js';\nimport { microTask as ye } from '../../utils/micro-task.js';\nimport { getOwnerDocument as xe } from '../../utils/owner.js';\nimport { RenderFeatures as oe, forwardRefWithAs as O, mergeProps as le, render as N } from '../../utils/render.js';\nimport { StableCollection as ge, useStableCollectionIndex as se } from '../../utils/stable-collection.js';\nimport { Keys as y } from '../keyboard.js';\nvar Ae = (t => (t[t.Forwards = 0] = \"Forwards\", t[t.Backwards = 1] = \"Backwards\", t))(Ae || {}),\n  Ee = (o => (o[o.Less = -1] = \"Less\", o[o.Equal = 0] = \"Equal\", o[o.Greater = 1] = \"Greater\", o))(Ee || {}),\n  Re = (n => (n[n.SetSelectedIndex = 0] = \"SetSelectedIndex\", n[n.RegisterTab = 1] = \"RegisterTab\", n[n.UnregisterTab = 2] = \"UnregisterTab\", n[n.RegisterPanel = 3] = \"RegisterPanel\", n[n.UnregisterPanel = 4] = \"UnregisterPanel\", n))(Re || {});\nlet Le = {\n    [0](e, r) {\n      var c;\n      let t = H(e.tabs, T => T.current),\n        o = H(e.panels, T => T.current),\n        a = t.filter(T => {\n          var d;\n          return !((d = T.current) != null && d.hasAttribute(\"disabled\"));\n        }),\n        n = {\n          ...e,\n          tabs: t,\n          panels: o\n        };\n      if (r.index < 0 || r.index > t.length - 1) {\n        let T = w(Math.sign(r.index - e.selectedIndex), {\n          [-1]: () => 1,\n          [0]: () => w(Math.sign(r.index), {\n            [-1]: () => 0,\n            [0]: () => 0,\n            [1]: () => 1\n          }),\n          [1]: () => 0\n        });\n        if (a.length === 0) return n;\n        let d = w(T, {\n          [0]: () => t.indexOf(a[0]),\n          [1]: () => t.indexOf(a[a.length - 1])\n        });\n        return {\n          ...n,\n          selectedIndex: d === -1 ? e.selectedIndex : d\n        };\n      }\n      let u = t.slice(0, r.index),\n        x = [...t.slice(r.index), ...u].find(T => a.includes(T));\n      if (!x) return n;\n      let f = (c = t.indexOf(x)) != null ? c : e.selectedIndex;\n      return f === -1 && (f = e.selectedIndex), {\n        ...n,\n        selectedIndex: f\n      };\n    },\n    [1](e, r) {\n      if (e.tabs.includes(r.tab)) return e;\n      let t = e.tabs[e.selectedIndex],\n        o = H([...e.tabs, r.tab], n => n.current),\n        a = e.selectedIndex;\n      return e.info.current.isControlled || (a = o.indexOf(t), a === -1 && (a = e.selectedIndex)), {\n        ...e,\n        tabs: o,\n        selectedIndex: a\n      };\n    },\n    [2](e, r) {\n      return {\n        ...e,\n        tabs: e.tabs.filter(t => t !== r.tab)\n      };\n    },\n    [3](e, r) {\n      return e.panels.includes(r.panel) ? e : {\n        ...e,\n        panels: H([...e.panels, r.panel], t => t.current)\n      };\n    },\n    [4](e, r) {\n      return {\n        ...e,\n        panels: e.panels.filter(t => t !== r.panel)\n      };\n    }\n  },\n  z = re(null);\nz.displayName = \"TabsDataContext\";\nfunction C(e) {\n  let r = ne(z);\n  if (r === null) {\n    let t = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, C), t;\n  }\n  return r;\n}\nlet V = re(null);\nV.displayName = \"TabsActionsContext\";\nfunction Q(e) {\n  let r = ne(V);\n  if (r === null) {\n    let t = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, Q), t;\n  }\n  return r;\n}\nfunction _e(e, r) {\n  return w(r.type, Le, e, r);\n}\nlet De = \"div\";\nfunction Se(e, r) {\n  let {\n    defaultIndex: t = 0,\n    vertical: o = !1,\n    manual: a = !1,\n    onChange: n,\n    selectedIndex: u = null,\n    ..._\n  } = e;\n  const x = o ? \"vertical\" : \"horizontal\",\n    f = a ? \"manual\" : \"auto\";\n  let c = u !== null,\n    T = j({\n      isControlled: c\n    }),\n    d = U(r),\n    [i, s] = ce(_e, {\n      info: T,\n      selectedIndex: u != null ? u : t,\n      tabs: [],\n      panels: []\n    }),\n    F = D(() => ({\n      selectedIndex: i.selectedIndex\n    }), [i.selectedIndex]),\n    M = j(n || (() => {})),\n    b = j(i.tabs),\n    m = D(() => ({\n      orientation: x,\n      activation: f,\n      ...i\n    }), [x, f, i]),\n    E = S(p => (s({\n      type: 1,\n      tab: p\n    }), () => s({\n      type: 2,\n      tab: p\n    }))),\n    I = S(p => (s({\n      type: 3,\n      panel: p\n    }), () => s({\n      type: 4,\n      panel: p\n    }))),\n    g = S(p => {\n      R.current !== p && M.current(p), c || s({\n        type: 0,\n        index: p\n      });\n    }),\n    R = j(c ? e.selectedIndex : i.selectedIndex),\n    J = D(() => ({\n      registerTab: E,\n      registerPanel: I,\n      change: g\n    }), []);\n  W(() => {\n    s({\n      type: 0,\n      index: u != null ? u : t\n    });\n  }, [u]), W(() => {\n    if (R.current === void 0 || i.tabs.length <= 0) return;\n    let p = H(i.tabs, L => L.current);\n    p.some((L, B) => i.tabs[B] !== L) && g(p.indexOf(i.tabs[R.current]));\n  });\n  let k = {\n    ref: d\n  };\n  return G.createElement(ge, null, G.createElement(V.Provider, {\n    value: J\n  }, G.createElement(z.Provider, {\n    value: m\n  }, m.tabs.length <= 0 && G.createElement(me, {\n    onFocus: () => {\n      var p, h;\n      for (let L of b.current) if (((p = L.current) == null ? void 0 : p.tabIndex) === 0) return (h = L.current) == null || h.focus(), !0;\n      return !1;\n    }\n  }), N({\n    ourProps: k,\n    theirProps: _,\n    slot: F,\n    defaultTag: De,\n    name: \"Tabs\"\n  }))));\n}\nlet Fe = \"div\";\nfunction Ie(e, r) {\n  let {\n      orientation: t,\n      selectedIndex: o\n    } = C(\"Tab.List\"),\n    a = U(r),\n    n = D(() => ({\n      selectedIndex: o\n    }), [o]);\n  return N({\n    ourProps: {\n      ref: a,\n      role: \"tablist\",\n      \"aria-orientation\": t\n    },\n    theirProps: e,\n    slot: n,\n    defaultTag: Fe,\n    name: \"Tabs.List\"\n  });\n}\nlet he = \"button\";\nfunction ve(e, r) {\n  var Y, Z;\n  let t = ae(),\n    {\n      id: o = `headlessui-tabs-tab-${t}`,\n      disabled: a = !1,\n      autoFocus: n = !1,\n      ...u\n    } = e,\n    {\n      orientation: _,\n      activation: x,\n      selectedIndex: f,\n      tabs: c,\n      panels: T\n    } = C(\"Tab\"),\n    d = Q(\"Tab\"),\n    i = C(\"Tab\"),\n    s = q(null),\n    F = U(s, r);\n  W(() => d.registerTab(s), [d, s]);\n  let M = se(\"tabs\"),\n    b = c.indexOf(s);\n  b === -1 && (b = M);\n  let m = b === f,\n    E = S(l => {\n      var X;\n      let A = l();\n      if (A === K.Success && x === \"auto\") {\n        let $ = (X = xe(s)) == null ? void 0 : X.activeElement,\n          ee = i.tabs.findIndex(Te => Te.current === $);\n        ee !== -1 && d.change(ee);\n      }\n      return A;\n    }),\n    I = S(l => {\n      let A = c.map($ => $.current).filter(Boolean);\n      if (l.key === y.Space || l.key === y.Enter) {\n        l.preventDefault(), l.stopPropagation(), d.change(b);\n        return;\n      }\n      switch (l.key) {\n        case y.Home:\n        case y.PageUp:\n          return l.preventDefault(), l.stopPropagation(), E(() => v(A, P.First));\n        case y.End:\n        case y.PageDown:\n          return l.preventDefault(), l.stopPropagation(), E(() => v(A, P.Last));\n      }\n      if (E(() => w(_, {\n        vertical() {\n          return l.key === y.ArrowUp ? v(A, P.Previous | P.WrapAround) : l.key === y.ArrowDown ? v(A, P.Next | P.WrapAround) : K.Error;\n        },\n        horizontal() {\n          return l.key === y.ArrowLeft ? v(A, P.Previous | P.WrapAround) : l.key === y.ArrowRight ? v(A, P.Next | P.WrapAround) : K.Error;\n        }\n      })) === K.Success) return l.preventDefault();\n    }),\n    g = q(!1),\n    R = S(() => {\n      var l;\n      g.current || (g.current = !0, (l = s.current) == null || l.focus({\n        preventScroll: !0\n      }), d.change(b), ye(() => {\n        g.current = !1;\n      }));\n    }),\n    J = S(l => {\n      l.preventDefault();\n    }),\n    {\n      isFocusVisible: k,\n      focusProps: p\n    } = te({\n      autoFocus: n\n    }),\n    {\n      isHovered: h,\n      hoverProps: L\n    } = de({\n      isDisabled: a\n    }),\n    {\n      pressed: B,\n      pressProps: ie\n    } = fe({\n      disabled: a\n    }),\n    pe = D(() => ({\n      selected: m,\n      hover: h,\n      active: B,\n      focus: k,\n      autofocus: n,\n      disabled: a\n    }), [m, h, k, B, n, a]),\n    ue = le({\n      ref: F,\n      onKeyDown: I,\n      onMouseDown: J,\n      onClick: R,\n      id: o,\n      role: \"tab\",\n      type: be(e, s),\n      \"aria-controls\": (Z = (Y = T[b]) == null ? void 0 : Y.current) == null ? void 0 : Z.id,\n      \"aria-selected\": m,\n      tabIndex: m ? 0 : -1,\n      disabled: a || void 0,\n      autoFocus: n\n    }, p, L, ie);\n  return N({\n    ourProps: ue,\n    theirProps: u,\n    slot: pe,\n    defaultTag: he,\n    name: \"Tabs.Tab\"\n  });\n}\nlet Ce = \"div\";\nfunction Me(e, r) {\n  let {\n      selectedIndex: t\n    } = C(\"Tab.Panels\"),\n    o = U(r),\n    a = D(() => ({\n      selectedIndex: t\n    }), [t]);\n  return N({\n    ourProps: {\n      ref: o\n    },\n    theirProps: e,\n    slot: a,\n    defaultTag: Ce,\n    name: \"Tabs.Panels\"\n  });\n}\nlet Ge = \"div\",\n  Ue = oe.RenderStrategy | oe.Static;\nfunction He(e, r) {\n  var E, I, g, R;\n  let t = ae(),\n    {\n      id: o = `headlessui-tabs-panel-${t}`,\n      tabIndex: a = 0,\n      ...n\n    } = e,\n    {\n      selectedIndex: u,\n      tabs: _,\n      panels: x\n    } = C(\"Tab.Panel\"),\n    f = Q(\"Tab.Panel\"),\n    c = q(null),\n    T = U(c, r);\n  W(() => f.registerPanel(c), [f, c]);\n  let d = se(\"panels\"),\n    i = x.indexOf(c);\n  i === -1 && (i = d);\n  let s = i === u,\n    {\n      isFocusVisible: F,\n      focusProps: M\n    } = te(),\n    b = D(() => ({\n      selected: s,\n      focus: F\n    }), [s, F]),\n    m = le({\n      ref: T,\n      id: o,\n      role: \"tabpanel\",\n      \"aria-labelledby\": (I = (E = _[i]) == null ? void 0 : E.current) == null ? void 0 : I.id,\n      tabIndex: s ? a : -1\n    }, M);\n  return !s && ((g = n.unmount) == null || g) && !((R = n.static) != null && R) ? G.createElement(Pe, {\n    \"aria-hidden\": \"true\",\n    ...m\n  }) : N({\n    ourProps: m,\n    theirProps: n,\n    slot: b,\n    defaultTag: Ge,\n    features: Ue,\n    visible: s,\n    name: \"Tabs.Panel\"\n  });\n}\nlet we = O(ve),\n  Oe = O(Se),\n  Ne = O(Ie),\n  ke = O(Me),\n  Be = O(He),\n  st = Object.assign(we, {\n    Group: Oe,\n    List: Ne,\n    Panels: ke,\n    Panel: Be\n  });\nexport { st as Tab, Oe as TabGroup, Ne as TabList, Be as TabPanel, ke as TabPanels };","map":null,"metadata":{},"sourceType":"module"}