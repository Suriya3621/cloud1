{"ast":null,"code":"import { autoUpdate as Z, flip as ee, inner as te, offset as ne, shift as le, size as re, useFloating as oe, useInnerOffset as ie, useInteractions as se } from \"@floating-ui/react\";\nimport * as j from \"react\";\nimport { createContext as _, useCallback as ae, useContext as R, useMemo as v, useRef as ue, useState as E } from \"react\";\nimport { useDisposables as fe } from '../hooks/use-disposables.js';\nimport { useEvent as z } from '../hooks/use-event.js';\nimport { useIsoMorphicEffect as A } from '../hooks/use-iso-morphic-effect.js';\nlet y = _({\n  styles: void 0,\n  setReference: () => {},\n  setFloating: () => {},\n  getReferenceProps: () => ({}),\n  getFloatingProps: () => ({}),\n  slot: {}\n});\ny.displayName = \"FloatingContext\";\nlet S = _(null);\nS.displayName = \"PlacementContext\";\nfunction xe(e) {\n  return v(() => e ? typeof e == \"string\" ? {\n    to: e\n  } : e : null, [e]);\n}\nfunction ye() {\n  return R(y).setReference;\n}\nfunction Fe() {\n  return R(y).getReferenceProps;\n}\nfunction be() {\n  let {\n    getFloatingProps: e,\n    slot: t\n  } = R(y);\n  return ae((...n) => Object.assign({}, e(...n), {\n    \"data-anchor\": t.anchor\n  }), [e, t]);\n}\nfunction Re(e = null) {\n  e === !1 && (e = null), typeof e == \"string\" && (e = {\n    to: e\n  });\n  let t = R(S),\n    n = v(() => e, [JSON.stringify(e, typeof HTMLElement != \"undefined\" ? (r, o) => o instanceof HTMLElement ? o.outerHTML : o : void 0)]);\n  A(() => {\n    t == null || t(n != null ? n : null);\n  }, [t, n]);\n  let l = R(y);\n  return v(() => [l.setFloating, e ? l.styles : {}], [l.setFloating, e, l.styles]);\n}\nlet q = 4;\nfunction ve({\n  children: e,\n  enabled: t = !0\n}) {\n  let [n, l] = E(null),\n    [r, o] = E(0),\n    c = ue(null),\n    [u, s] = E(null);\n  pe(u);\n  let i = t && n !== null && u !== null,\n    {\n      to: F = \"bottom\",\n      gap: C = 0,\n      offset: M = 0,\n      padding: p = 0,\n      inner: P\n    } = ce(n, u),\n    [a, f = \"center\"] = F.split(\" \");\n  A(() => {\n    i && o(0);\n  }, [i]);\n  let {\n      refs: b,\n      floatingStyles: w,\n      context: g\n    } = oe({\n      open: i,\n      placement: a === \"selection\" ? f === \"center\" ? \"bottom\" : `bottom-${f}` : f === \"center\" ? `${a}` : `${a}-${f}`,\n      strategy: \"absolute\",\n      transform: !1,\n      middleware: [ne({\n        mainAxis: a === \"selection\" ? 0 : C,\n        crossAxis: M\n      }), le({\n        padding: p\n      }), a !== \"selection\" && ee({\n        padding: p\n      }), a === \"selection\" && P ? te({\n        ...P,\n        padding: p,\n        overflowRef: c,\n        offset: r,\n        minItemsVisible: q,\n        referenceOverflowThreshold: p,\n        onFallbackChange(h) {\n          var O, W;\n          if (!h) return;\n          let d = g.elements.floating;\n          if (!d) return;\n          let T = parseFloat(getComputedStyle(d).scrollPaddingBottom) || 0,\n            $ = Math.min(q, d.childElementCount),\n            B = 0,\n            N = 0;\n          for (let m of (W = (O = g.elements.floating) == null ? void 0 : O.childNodes) != null ? W : []) if (m instanceof HTMLElement) {\n            let x = m.offsetTop,\n              k = x + m.clientHeight + T,\n              H = d.scrollTop,\n              U = H + d.clientHeight;\n            if (x >= H && k <= U) $--;else {\n              N = Math.max(0, Math.min(k, U) - Math.max(x, H)), B = m.clientHeight;\n              break;\n            }\n          }\n          $ >= 1 && o(m => {\n            let x = B * $ - N + T;\n            return m >= x ? m : x;\n          });\n        }\n      }) : null, re({\n        padding: p,\n        apply({\n          availableWidth: h,\n          availableHeight: d,\n          elements: T\n        }) {\n          Object.assign(T.floating.style, {\n            overflow: \"auto\",\n            maxWidth: `${h}px`,\n            maxHeight: `min(var(--anchor-max-height, 100vh), ${d}px)`\n          });\n        }\n      })].filter(Boolean),\n      whileElementsMounted: Z\n    }),\n    [I = a, V = f] = g.placement.split(\"-\");\n  a === \"selection\" && (I = \"selection\");\n  let G = v(() => ({\n      anchor: [I, V].filter(Boolean).join(\" \")\n    }), [I, V]),\n    K = ie(g, {\n      overflowRef: c,\n      onChange: o\n    }),\n    {\n      getReferenceProps: Q,\n      getFloatingProps: X\n    } = se([K]),\n    Y = z(h => {\n      s(h), b.setFloating(h);\n    });\n  return j.createElement(S.Provider, {\n    value: l\n  }, j.createElement(y.Provider, {\n    value: {\n      setFloating: Y,\n      setReference: b.setReference,\n      styles: w,\n      getReferenceProps: Q,\n      getFloatingProps: X,\n      slot: G\n    }\n  }, e));\n}\nfunction pe(e) {\n  A(() => {\n    if (!e) return;\n    let t = new MutationObserver(() => {\n      let n = window.getComputedStyle(e).maxHeight,\n        l = parseFloat(n);\n      if (isNaN(l)) return;\n      let r = parseInt(n);\n      isNaN(r) || l !== r && (e.style.maxHeight = `${Math.ceil(l)}px`);\n    });\n    return t.observe(e, {\n      attributes: !0,\n      attributeFilter: [\"style\"]\n    }), () => {\n      t.disconnect();\n    };\n  }, [e]);\n}\nfunction ce(e, t) {\n  var o, c, u;\n  let n = L((o = e == null ? void 0 : e.gap) != null ? o : \"var(--anchor-gap, 0)\", t),\n    l = L((c = e == null ? void 0 : e.offset) != null ? c : \"var(--anchor-offset, 0)\", t),\n    r = L((u = e == null ? void 0 : e.padding) != null ? u : \"var(--anchor-padding, 0)\", t);\n  return {\n    ...e,\n    gap: n,\n    offset: l,\n    padding: r\n  };\n}\nfunction L(e, t, n = void 0) {\n  let l = fe(),\n    r = z((s, i) => {\n      if (s == null) return [n, null];\n      if (typeof s == \"number\") return [s, null];\n      if (typeof s == \"string\") {\n        if (!i) return [n, null];\n        let F = J(s, i);\n        return [F, C => {\n          let M = D(s);\n          {\n            let p = M.map(P => window.getComputedStyle(i).getPropertyValue(P));\n            l.requestAnimationFrame(function P() {\n              l.nextFrame(P);\n              let a = !1;\n              for (let [b, w] of M.entries()) {\n                let g = window.getComputedStyle(i).getPropertyValue(w);\n                if (p[b] !== g) {\n                  p[b] = g, a = !0;\n                  break;\n                }\n              }\n              if (!a) return;\n              let f = J(s, i);\n              F !== f && (C(f), F = f);\n            });\n          }\n          return l.dispose;\n        }];\n      }\n      return [n, null];\n    }),\n    o = v(() => r(e, t)[0], [e, t]),\n    [c = o, u] = E();\n  return A(() => {\n    let [s, i] = r(e, t);\n    if (u(s), !!i) return i(u);\n  }, [e, t]), c;\n}\nfunction D(e) {\n  let t = /var\\((.*)\\)/.exec(e);\n  if (t) {\n    let n = t[1].indexOf(\",\");\n    if (n === -1) return [t[1]];\n    let l = t[1].slice(0, n).trim(),\n      r = t[1].slice(n + 1).trim();\n    return r ? [l, ...D(r)] : [l];\n  }\n  return [];\n}\nfunction J(e, t) {\n  let n = document.createElement(\"div\");\n  t.appendChild(n), n.style.setProperty(\"margin-top\", \"0px\", \"important\"), n.style.setProperty(\"margin-top\", e, \"important\");\n  let l = parseFloat(window.getComputedStyle(n).marginTop) || 0;\n  return t.removeChild(n), l;\n}\nexport { ve as FloatingProvider, Re as useFloatingPanel, be as useFloatingPanelProps, ye as useFloatingReference, Fe as useFloatingReferenceProps, xe as useResolvedAnchor };","map":null,"metadata":{},"sourceType":"module"}