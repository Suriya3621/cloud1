{"ast":null,"code":"\"use client\";\n\nimport f, { Fragment as g, createContext as E, useContext as T, useEffect as R, useMemo as c, useRef as A, useState as G } from \"react\";\nimport { createPortal as H } from \"react-dom\";\nimport { useEvent as L } from '../../hooks/use-event.js';\nimport { useIsoMorphicEffect as x } from '../../hooks/use-iso-morphic-effect.js';\nimport { useOnUnmount as O } from '../../hooks/use-on-unmount.js';\nimport { useOwnerDocument as _ } from '../../hooks/use-owner.js';\nimport { useServerHandoffComplete as h } from '../../hooks/use-server-handoff-complete.js';\nimport { optionalRef as F, useSyncRefs as P } from '../../hooks/use-sync-refs.js';\nimport { usePortalRoot as U } from '../../internal/portal-force-root.js';\nimport { env as C } from '../../utils/env.js';\nimport { forwardRefWithAs as m, render as d } from '../../utils/render.js';\nfunction D(p) {\n  let r = U(),\n    l = T(v),\n    e = _(p),\n    [o, n] = G(() => {\n      var t;\n      if (!r && l !== null) return (t = l.current) != null ? t : null;\n      if (C.isServer) return null;\n      let u = e == null ? void 0 : e.getElementById(\"headlessui-portal-root\");\n      if (u) return u;\n      if (e === null) return null;\n      let a = e.createElement(\"div\");\n      return a.setAttribute(\"id\", \"headlessui-portal-root\"), e.body.appendChild(a);\n    });\n  return R(() => {\n    o !== null && (e != null && e.body.contains(o) || e == null || e.body.appendChild(o));\n  }, [o, e]), R(() => {\n    r || l !== null && n(l.current);\n  }, [l, n, r]), o;\n}\nlet M = g,\n  N = m(function (r, l) {\n    let e = r,\n      o = A(null),\n      n = P(F(i => {\n        o.current = i;\n      }), l),\n      u = _(o),\n      a = D(o),\n      [t] = G(() => {\n        var i;\n        return C.isServer ? null : (i = u == null ? void 0 : u.createElement(\"div\")) != null ? i : null;\n      }),\n      s = T(y),\n      b = h();\n    return x(() => {\n      !a || !t || a.contains(t) || (t.setAttribute(\"data-headlessui-portal\", \"\"), a.appendChild(t));\n    }, [a, t]), x(() => {\n      if (t && s) return s.register(t);\n    }, [s, t]), O(() => {\n      var i;\n      !a || !t || (t instanceof Node && a.contains(t) && a.removeChild(t), a.childNodes.length <= 0 && ((i = a.parentElement) == null || i.removeChild(a)));\n    }), b ? !a || !t ? null : H(d({\n      ourProps: {\n        ref: n\n      },\n      theirProps: e,\n      slot: {},\n      defaultTag: M,\n      name: \"Portal\"\n    }), t) : null;\n  });\nfunction S(p, r) {\n  let l = P(r),\n    {\n      enabled: e = !0,\n      ...o\n    } = p;\n  return e ? f.createElement(N, {\n    ...o,\n    ref: l\n  }) : d({\n    ourProps: {\n      ref: l\n    },\n    theirProps: o,\n    slot: {},\n    defaultTag: M,\n    name: \"Portal\"\n  });\n}\nlet j = g,\n  v = E(null);\nfunction W(p, r) {\n  let {\n      target: l,\n      ...e\n    } = p,\n    n = {\n      ref: P(r)\n    };\n  return f.createElement(v.Provider, {\n    value: l\n  }, d({\n    ourProps: n,\n    theirProps: e,\n    defaultTag: j,\n    name: \"Popover.Group\"\n  }));\n}\nlet y = E(null);\nfunction ee() {\n  let p = T(y),\n    r = A([]),\n    l = L(n => (r.current.push(n), p && p.register(n), () => e(n))),\n    e = L(n => {\n      let u = r.current.indexOf(n);\n      u !== -1 && r.current.splice(u, 1), p && p.unregister(n);\n    }),\n    o = c(() => ({\n      register: l,\n      unregister: e,\n      portals: r\n    }), [l, e, r]);\n  return [r, c(() => function ({\n    children: u\n  }) {\n    return f.createElement(y.Provider, {\n      value: o\n    }, u);\n  }, [o])];\n}\nlet I = m(S),\n  J = m(W),\n  te = Object.assign(I, {\n    Group: J\n  });\nexport { te as Portal, J as PortalGroup, ee as useNestedPortals };","map":null,"metadata":{},"sourceType":"module"}