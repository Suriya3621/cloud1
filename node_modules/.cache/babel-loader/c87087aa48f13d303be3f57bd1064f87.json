{"ast":null,"code":"import { useRef as b, useState as S } from \"react\";\nimport { disposables as E } from '../utils/disposables.js';\nimport { once as g } from '../utils/once.js';\nimport { useDisposables as L } from './use-disposables.js';\nimport { useFlags as y } from './use-flags.js';\nimport { useIsoMorphicEffect as C } from './use-iso-morphic-effect.js';\nvar D = (i => (i[i.None = 0] = \"None\", i[i.Closed = 1] = \"Closed\", i[i.Enter = 2] = \"Enter\", i[i.Leave = 4] = \"Leave\", i))(D || {});\nfunction A(e) {\n  let a = {};\n  for (let t in e) e[t] === !0 && (a[`data-${t}`] = \"\");\n  return a;\n}\nfunction V(e, a, t, r) {\n  let [i, u] = S(t),\n    {\n      hasFlag: d,\n      addFlag: f,\n      removeFlag: s\n    } = y(e && i ? 3 : 0),\n    l = b(!1),\n    n = b(!1),\n    o = L();\n  return C(function p() {\n    var T;\n    if (!e) return;\n    t && u(!0);\n    let c = a.current;\n    return c ? ((T = r == null ? void 0 : r.start) == null || T.call(r, t), M(c, {\n      inFlight: l,\n      prepare() {\n        n.current ? n.current = !1 : n.current = l.current, l.current = !0, !n.current && (t ? (f(3), s(4)) : (f(4), s(2)));\n      },\n      run() {\n        n.current ? t ? (s(3), f(4)) : (s(4), f(3)) : t ? s(1) : f(1);\n      },\n      done() {\n        var m;\n        n.current && typeof c.getAnimations == \"function\" && c.getAnimations().length > 0 || (l.current = !1, s(7), t || u(!1), (m = r == null ? void 0 : r.end) == null || m.call(r, t));\n      }\n    })) : t ? (f(3), o.nextFrame(() => p())) : void 0;\n  }, [e, t, a, o]), e ? [i, {\n    closed: d(1),\n    enter: d(2),\n    leave: d(4),\n    transition: d(2) || d(4)\n  }] : [t, {\n    closed: void 0,\n    enter: void 0,\n    leave: void 0,\n    transition: void 0\n  }];\n}\nfunction M(e, {\n  prepare: a,\n  run: t,\n  done: r,\n  inFlight: i\n}) {\n  let u = E();\n  return R(e, {\n    prepare: a,\n    inFlight: i\n  }), u.nextFrame(() => {\n    u.add(F(e, r)), t();\n  }), u.dispose;\n}\nfunction F(e, a) {\n  let t = g(a),\n    r = E();\n  if (!e) return r.dispose;\n  let {\n      transitionDuration: i,\n      transitionDelay: u\n    } = getComputedStyle(e),\n    [d, f] = [i, u].map(l => {\n      let [n = 0] = l.split(\",\").filter(Boolean).map(o => o.includes(\"ms\") ? parseFloat(o) : parseFloat(o) * 1e3).sort((o, p) => p - o);\n      return n;\n    }),\n    s = d + f;\n  if (s !== 0) {\n    let l = r.group(n => {\n      let o = n.setTimeout(() => {\n        t(), n.dispose();\n      }, s);\n      n.addEventListener(e, \"transitionrun\", p => {\n        p.target === p.currentTarget && (o(), n.addEventListener(e, \"transitioncancel\", c => {\n          c.target === c.currentTarget && (t(), l());\n        }));\n      });\n    });\n    r.addEventListener(e, \"transitionend\", n => {\n      n.target === n.currentTarget && (t(), r.dispose());\n    });\n  } else t();\n  return r.dispose;\n}\nfunction R(e, {\n  inFlight: a,\n  prepare: t\n}) {\n  if (a != null && a.current) {\n    t();\n    return;\n  }\n  let r = e.style.transition;\n  e.style.transition = \"none\", t(), e.offsetHeight, e.style.transition = r;\n}\nexport { A as transitionDataAttributes, V as useTransition };","map":null,"metadata":{},"sourceType":"module"}