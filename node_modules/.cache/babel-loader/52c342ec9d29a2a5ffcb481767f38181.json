{"ast":null,"code":"import { Fragment as R, cloneElement as P, createElement as E, forwardRef as j, isValidElement as v, useCallback as S, useRef as w } from \"react\";\nimport { classNames as x } from './class-names.js';\nimport { match as k } from './match.js';\nvar M = (a => (a[a.None = 0] = \"None\", a[a.RenderStrategy = 1] = \"RenderStrategy\", a[a.Static = 2] = \"Static\", a))(M || {}),\n  O = (e => (e[e.Unmount = 0] = \"Unmount\", e[e.Hidden = 1] = \"Hidden\", e))(O || {});\nfunction H({\n  ourProps: r,\n  theirProps: n,\n  slot: e,\n  defaultTag: a,\n  features: s,\n  visible: t = !0,\n  name: l,\n  mergeRefs: i\n}) {\n  i = i != null ? i : A;\n  let o = N(n, r);\n  if (t) return b(o, e, a, l, i);\n  let y = s != null ? s : 0;\n  if (y & 2) {\n    let {\n      static: f = !1,\n      ...u\n    } = o;\n    if (f) return b(u, e, a, l, i);\n  }\n  if (y & 1) {\n    let {\n      unmount: f = !0,\n      ...u\n    } = o;\n    return k(f ? 0 : 1, {\n      [0]() {\n        return null;\n      },\n      [1]() {\n        return b({\n          ...u,\n          hidden: !0,\n          style: {\n            display: \"none\"\n          }\n        }, e, a, l, i);\n      }\n    });\n  }\n  return b(o, e, a, l, i);\n}\nfunction b(r, n = {}, e, a, s) {\n  let {\n      as: t = e,\n      children: l,\n      refName: i = \"ref\",\n      ...o\n    } = h(r, [\"unmount\", \"static\"]),\n    y = r.ref !== void 0 ? {\n      [i]: r.ref\n    } : {},\n    f = typeof l == \"function\" ? l(n) : l;\n  \"className\" in o && o.className && typeof o.className == \"function\" && (o.className = o.className(n)), o[\"aria-labelledby\"] && o[\"aria-labelledby\"] === o.id && (o[\"aria-labelledby\"] = void 0);\n  let u = {};\n  if (n) {\n    let d = !1,\n      p = [];\n    for (let [c, T] of Object.entries(n)) typeof T == \"boolean\" && (d = !0), T === !0 && p.push(c.replace(/([A-Z])/g, g => `-${g.toLowerCase()}`));\n    if (d) {\n      u[\"data-headlessui-state\"] = p.join(\" \");\n      for (let c of p) u[`data-${c}`] = \"\";\n    }\n  }\n  if (t === R && (Object.keys(m(o)).length > 0 || Object.keys(m(u)).length > 0)) if (!v(f) || Array.isArray(f) && f.length > 1) {\n    if (Object.keys(m(o)).length > 0) throw new Error(['Passing props on \"Fragment\"!', \"\", `The current component <${a} /> is rendering a \"Fragment\".`, \"However we need to passthrough the following props:\", Object.keys(m(o)).concat(Object.keys(m(u))).map(d => `  - ${d}`).join(`\n`), \"\", \"You can apply a few solutions:\", ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', \"Render a single element as the child so that we can forward the props onto that element.\"].map(d => `  - ${d}`).join(`\n`)].join(`\n`));\n  } else {\n    let d = f.props,\n      p = d == null ? void 0 : d.className,\n      c = typeof p == \"function\" ? (...F) => x(p(...F), o.className) : x(p, o.className),\n      T = c ? {\n        className: c\n      } : {},\n      g = N(f.props, m(h(o, [\"ref\"])));\n    for (let F in u) F in g && delete u[F];\n    return P(f, Object.assign({}, g, u, y, {\n      ref: s(f.ref, y.ref)\n    }, T));\n  }\n  return E(t, Object.assign({}, h(o, [\"ref\"]), t !== R && y, t !== R && u), f);\n}\nfunction I() {\n  let r = w([]),\n    n = S(e => {\n      for (let a of r.current) a != null && (typeof a == \"function\" ? a(e) : a.current = e);\n    }, []);\n  return (...e) => {\n    if (!e.every(a => a == null)) return r.current = e, n;\n  };\n}\nfunction A(...r) {\n  return r.every(n => n == null) ? void 0 : n => {\n    for (let e of r) e != null && (typeof e == \"function\" ? e(n) : e.current = n);\n  };\n}\nfunction N(...r) {\n  var a;\n  if (r.length === 0) return {};\n  if (r.length === 1) return r[0];\n  let n = {},\n    e = {};\n  for (let s of r) for (let t in s) t.startsWith(\"on\") && typeof s[t] == \"function\" ? ((a = e[t]) != null || (e[t] = []), e[t].push(s[t])) : n[t] = s[t];\n  if (n.disabled || n[\"aria-disabled\"]) for (let s in e) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s) && (e[s] = [t => {\n    var l;\n    return (l = t == null ? void 0 : t.preventDefault) == null ? void 0 : l.call(t);\n  }]);\n  for (let s in e) Object.assign(n, {\n    [s](t, ...l) {\n      let i = e[s];\n      for (let o of i) {\n        if ((t instanceof Event || (t == null ? void 0 : t.nativeEvent) instanceof Event) && t.defaultPrevented) return;\n        o(t, ...l);\n      }\n    }\n  });\n  return n;\n}\nfunction D(...r) {\n  var a;\n  if (r.length === 0) return {};\n  if (r.length === 1) return r[0];\n  let n = {},\n    e = {};\n  for (let s of r) for (let t in s) t.startsWith(\"on\") && typeof s[t] == \"function\" ? ((a = e[t]) != null || (e[t] = []), e[t].push(s[t])) : n[t] = s[t];\n  for (let s in e) Object.assign(n, {\n    [s](...t) {\n      let l = e[s];\n      for (let i of l) i == null || i(...t);\n    }\n  });\n  return n;\n}\nfunction W(r) {\n  var n;\n  return Object.assign(j(r), {\n    displayName: (n = r.displayName) != null ? n : r.name\n  });\n}\nfunction m(r) {\n  let n = Object.assign({}, r);\n  for (let e in n) n[e] === void 0 && delete n[e];\n  return n;\n}\nfunction h(r, n = []) {\n  let e = Object.assign({}, r);\n  for (let a of n) a in e && delete e[a];\n  return e;\n}\nexport { M as RenderFeatures, O as RenderStrategy, m as compact, W as forwardRefWithAs, D as mergeProps, H as render, I as useMergeRefsFn };","map":null,"metadata":{},"sourceType":"module"}