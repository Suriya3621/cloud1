{"ast":null,"code":"\"use client\";\n\nimport L, { useRef as M } from \"react\";\nimport { useDisposables as G } from '../../hooks/use-disposables.js';\nimport { useEvent as A } from '../../hooks/use-event.js';\nimport { useEventListener as W } from '../../hooks/use-event-listener.js';\nimport { useIsMounted as P } from '../../hooks/use-is-mounted.js';\nimport { useIsTopLayer as O } from '../../hooks/use-is-top-layer.js';\nimport { useOnUnmount as K } from '../../hooks/use-on-unmount.js';\nimport { useOwnerDocument as V } from '../../hooks/use-owner.js';\nimport { useServerHandoffComplete as q } from '../../hooks/use-server-handoff-complete.js';\nimport { useSyncRefs as J } from '../../hooks/use-sync-refs.js';\nimport { Direction as H, useTabDirection as X } from '../../hooks/use-tab-direction.js';\nimport { useWatch as y } from '../../hooks/use-watch.js';\nimport { Hidden as C, HiddenFeatures as _ } from '../../internal/hidden.js';\nimport { history as b } from '../../utils/active-element-history.js';\nimport { Focus as T, FocusResult as S, focusElement as p, focusIn as E } from '../../utils/focus-management.js';\nimport { match as h } from '../../utils/match.js';\nimport { microTask as j } from '../../utils/micro-task.js';\nimport { forwardRefWithAs as z, render as Q } from '../../utils/render.js';\nfunction U(o) {\n  if (!o) return new Set();\n  if (typeof o == \"function\") return new Set(o());\n  let e = new Set();\n  for (let t of o.current) t.current instanceof HTMLElement && e.add(t.current);\n  return e;\n}\nlet Y = \"div\";\nvar x = (n => (n[n.None = 0] = \"None\", n[n.InitialFocus = 1] = \"InitialFocus\", n[n.TabLock = 2] = \"TabLock\", n[n.FocusLock = 4] = \"FocusLock\", n[n.RestoreFocus = 8] = \"RestoreFocus\", n[n.AutoFocus = 16] = \"AutoFocus\", n))(x || {});\nfunction Z(o, e) {\n  let t = M(null),\n    r = J(t, e),\n    {\n      initialFocus: s,\n      initialFocusFallback: a,\n      containers: n,\n      features: u = 15,\n      ...f\n    } = o;\n  q() || (u = 0);\n  let l = V(t);\n  w(u, {\n    ownerDocument: l\n  });\n  let i = ee(u, {\n    ownerDocument: l,\n    container: t,\n    initialFocus: s,\n    initialFocusFallback: a\n  });\n  te(u, {\n    ownerDocument: l,\n    container: t,\n    containers: n,\n    previousActiveElement: i\n  });\n  let R = X(),\n    g = A(c => {\n      let m = t.current;\n      if (!m) return;\n      (B => B())(() => {\n        h(R.current, {\n          [H.Forwards]: () => {\n            E(m, T.First, {\n              skipElements: [c.relatedTarget, a]\n            });\n          },\n          [H.Backwards]: () => {\n            E(m, T.Last, {\n              skipElements: [c.relatedTarget, a]\n            });\n          }\n        });\n      });\n    }),\n    v = O(!!(u & 2), \"focus-trap#tab-lock\"),\n    N = G(),\n    F = M(!1),\n    k = {\n      ref: r,\n      onKeyDown(c) {\n        c.key == \"Tab\" && (F.current = !0, N.requestAnimationFrame(() => {\n          F.current = !1;\n        }));\n      },\n      onBlur(c) {\n        if (!(u & 4)) return;\n        let m = U(n);\n        t.current instanceof HTMLElement && m.add(t.current);\n        let d = c.relatedTarget;\n        d instanceof HTMLElement && d.dataset.headlessuiFocusGuard !== \"true\" && (I(m, d) || (F.current ? E(t.current, h(R.current, {\n          [H.Forwards]: () => T.Next,\n          [H.Backwards]: () => T.Previous\n        }) | T.WrapAround, {\n          relativeTo: c.target\n        }) : c.target instanceof HTMLElement && p(c.target)));\n      }\n    };\n  return L.createElement(L.Fragment, null, v && L.createElement(C, {\n    as: \"button\",\n    type: \"button\",\n    \"data-headlessui-focus-guard\": !0,\n    onFocus: g,\n    features: _.Focusable\n  }), Q({\n    ourProps: k,\n    theirProps: f,\n    defaultTag: Y,\n    name: \"FocusTrap\"\n  }), v && L.createElement(C, {\n    as: \"button\",\n    type: \"button\",\n    \"data-headlessui-focus-guard\": !0,\n    onFocus: g,\n    features: _.Focusable\n  }));\n}\nlet $ = z(Z),\n  Fe = Object.assign($, {\n    features: x\n  });\nfunction D(o = !0) {\n  let e = M(b.slice());\n  return y(([t], [r]) => {\n    r === !0 && t === !1 && j(() => {\n      e.current.splice(0);\n    }), r === !1 && t === !0 && (e.current = b.slice());\n  }, [o, b, e]), A(() => {\n    var t;\n    return (t = e.current.find(r => r != null && r.isConnected)) != null ? t : null;\n  });\n}\nfunction w(o, {\n  ownerDocument: e\n}) {\n  let t = !!(o & 8),\n    r = D(t);\n  y(() => {\n    t || (e == null ? void 0 : e.activeElement) === (e == null ? void 0 : e.body) && p(r());\n  }, [t]), K(() => {\n    t && p(r());\n  });\n}\nfunction ee(o, {\n  ownerDocument: e,\n  container: t,\n  initialFocus: r,\n  initialFocusFallback: s\n}) {\n  let a = M(null),\n    n = O(!!(o & 1), \"focus-trap#initial-focus\"),\n    u = P();\n  return y(() => {\n    if (o === 0) return;\n    if (!n) {\n      s != null && s.current && p(s.current);\n      return;\n    }\n    let f = t.current;\n    f && j(() => {\n      if (!u.current) return;\n      let l = e == null ? void 0 : e.activeElement;\n      if (r != null && r.current) {\n        if ((r == null ? void 0 : r.current) === l) {\n          a.current = l;\n          return;\n        }\n      } else if (f.contains(l)) {\n        a.current = l;\n        return;\n      }\n      if (r != null && r.current) p(r.current);else {\n        if (o & 16) {\n          if (E(f, T.First | T.AutoFocus) !== S.Error) return;\n        } else if (E(f, T.First) !== S.Error) return;\n        if (s != null && s.current && (p(s.current), (e == null ? void 0 : e.activeElement) === s.current)) return;\n        console.warn(\"There are no focusable elements inside the <FocusTrap />\");\n      }\n      a.current = e == null ? void 0 : e.activeElement;\n    });\n  }, [s, n, o]), a;\n}\nfunction te(o, {\n  ownerDocument: e,\n  container: t,\n  containers: r,\n  previousActiveElement: s\n}) {\n  let a = P(),\n    n = !!(o & 4);\n  W(e == null ? void 0 : e.defaultView, \"focus\", u => {\n    if (!n || !a.current) return;\n    let f = U(r);\n    t.current instanceof HTMLElement && f.add(t.current);\n    let l = s.current;\n    if (!l) return;\n    let i = u.target;\n    i && i instanceof HTMLElement ? I(f, i) ? (s.current = i, p(i)) : (u.preventDefault(), u.stopPropagation(), p(l)) : p(s.current);\n  }, !0);\n}\nfunction I(o, e) {\n  for (let t of o) if (t.contains(e)) return !0;\n  return !1;\n}\nexport { Fe as FocusTrap, x as FocusTrapFeatures };","map":null,"metadata":{},"sourceType":"module"}